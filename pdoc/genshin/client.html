<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev21+g6d35cca" />
<title>genshin.client API documentation</title>
<meta name="description" content="A client interacting directly with the api" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>genshin.client</code></h1>
</header>
<section id="section-intro">
<p>A client interacting directly with the api</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A client interacting directly with the api&#34;&#34;&#34;
from __future__ import annotations

import asyncio
import base64
import json as json_
import logging
import os
import uuid
import warnings
from datetime import datetime
from http.cookies import SimpleCookie
from typing import *
from urllib.parse import unquote

import aiohttp
from yarl import URL

from . import errors
from .constants import CHARACTER_NAMES, LANGS
from .models import *
from .paginator import *
from .utils import *

__all__ = [
    &#34;GenshinClient&#34;,
    &#34;MultiCookieClient&#34;,
    &#34;ChineseClient&#34;,
    &#34;ChineseMultiCookieClient&#34;,
]


class GenshinClient:
    &#34;&#34;&#34;A simple http client for genshin endpoints

    :var logger: A logger used for debugging
    :var cache: A cache for http requests
    :var paginator_cache: A high-frequency access cache for paginators
    &#34;&#34;&#34;

    DS_SALT = &#34;6cqshh5dhw73bzxn20oexa9k516chk7s&#34;
    ACT_ID = &#34;e202102251931481&#34;

    WEBSTATIC_URL = &#34;https://webstatic-sea.hoyoverse.com/&#34;
    TAKUMI_URL = &#34;https://api-os-takumi.mihoyo.com/&#34;
    RECORD_URL = &#34;https://bbs-api-os.hoyoverse.com/game_record/&#34;
    INFO_LEDGER_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/ysledgeros/month_info&#34;
    DETAIL_LEDGER_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/ysledgeros/month_detail&#34;
    CALCULATOR_URL = &#34;https://sg-public-api.hoyoverse.com/event/calculateos/&#34;
    REWARD_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/sol/&#34;
    GACHA_INFO_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/gacha_info/api/&#34;
    YSULOG_URL = &#34;https://hk4e-api-os.hoyoverse.com/ysulog/api/&#34;
    MAP_URL = &#34;https://api-os-takumi-static.hoyoverse.com/common/map_user/ys_obc/v1/map/&#34;
    STATIC_MAP_URL = &#34;https://api-os-takumi-static.hoyoverse.com/common/map_user/ys_obc/v1/map&#34;

    USER_AGENT = &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#34;  # noqa: E501

    _session: Optional[aiohttp.ClientSession] = None
    _uid: Optional[int] = None
    logger: logging.Logger = logging.getLogger(__name__)

    cache: Optional[MutableMapping[Tuple[Any, ...], Any]] = None
    paginator_cache: Optional[MutableMapping[Tuple[Any, ...], Any]] = None

    fetched_mi18n: bool = False

    def __init__(
        self,
        cookies: Mapping[str, str] = None,
        authkey: str = None,
        *,
        lang: str = &#34;en-us&#34;,
        debug: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Create a new GenshinClient instance

        :param cookies: The cookies used for authenticaation
        :param authkey: The authkey used for paginators
        :param lang: The default language
        :param debug: Whether debug logs should be shown in stdout
        &#34;&#34;&#34;
        if cookies:
            self.cookies = cookies

        self.authkey = authkey
        self.lang = lang
        self.debug = debug

    def __repr__(self) -&gt; str:
        return f&#34;&lt;{type(self).__name__} lang={self.lang!r} hoyolab_uid={self.hoyolab_uid} debug={self.debug}&gt;&#34;

    # PROPERTIES:

    @property
    def session(self) -&gt; aiohttp.ClientSession:
        &#34;&#34;&#34;The current client session, created when needed&#34;&#34;&#34;
        if self._session is None:
            self._session = aiohttp.ClientSession()

        return self._session

    @property
    def cookies(self) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;The cookie jar belonging to the current session&#34;&#34;&#34;
        return {cookie.key: cookie.value for cookie in self.session.cookie_jar}

    @cookies.setter
    def cookies(self, cookies: Mapping[str, Any]) -&gt; None:
        cks = {str(key): value for key, value in cookies.items()}
        self.session.cookie_jar.clear()
        self.session.cookie_jar.update_cookies(cks)

    @property
    def hoyolab_uid(self) -&gt; Optional[int]:
        &#34;&#34;&#34;The logged-in user&#39;s hoyolab uid&#34;&#34;&#34;
        for cookie in self.session.cookie_jar:
            if cookie.key in (&#34;ltuid&#34;, &#34;account_id&#34;):
                return int(cookie.value)

        return None

    @property
    def uid(self) -&gt; Optional[int]:
        return self._uid

    @uid.setter
    def uid(self, uid: Any) -&gt; None:
        if not str(uid).isdigit() or len(str(uid)) != 9:
            raise TypeError(f&#34;Invalid uid: {uid}&#34;)

        self._uid = int(uid)

    @property
    def lang(self) -&gt; str:
        &#34;&#34;&#34;The default language, defaults to &#34;en-us&#34; &#34;&#34;&#34;
        return self._lang

    @lang.setter
    def lang(self, lang: str) -&gt; None:
        if lang not in LANGS:
            raise ValueError(f&#34;{lang} is not a valid language, must be one of: &#34; + &#34;, &#34;.join(LANGS))

        self._lang = lang

    @property
    def authkey(self) -&gt; Optional[str]:
        &#34;&#34;&#34;The default authkey&#34;&#34;&#34;
        return self._authkey

    @authkey.setter
    def authkey(self, authkey: Optional[str]) -&gt; None:
        if authkey is not None:
            authkey = unquote(authkey)

            try:
                base64.b64decode(authkey, validate=True)
            except Exception as e:
                raise ValueError(&#34;authkey is not a valid base64 encoded string&#34;) from e

        self._authkey = authkey

    @property
    def debug(self) -&gt; bool:
        &#34;&#34;&#34;Whether the debug logs are being shown in stdout&#34;&#34;&#34;
        return logging.getLogger(&#34;genshin&#34;).level == logging.DEBUG

    @debug.setter
    def debug(self, debug: bool) -&gt; None:
        logging.basicConfig()
        level = logging.DEBUG if debug else logging.NOTSET
        logging.getLogger(&#34;genshin&#34;).setLevel(level)

    def set_cookies(
        self, cookies: Union[Mapping[str, Any], str] = None, **kwargs: Any
    ) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;Helper cookie setter that accepts cookie headers

        :returns: The new cookies
        &#34;&#34;&#34;
        if not bool(cookies) ^ bool(kwargs):
            raise TypeError(&#34;Cannot use both positional and keyword arguments at once&#34;)

        cookies = cookies or kwargs
        cookies = {morsel.key: morsel.value for morsel in SimpleCookie(cookies).values()}
        self.cookies = cookies
        return self.cookies

    def set_browser_cookies(self, browser: str = None) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;Extract cookies from your browser and set them as client cookies

        Avalible browsers: chrome, chromium, opera, edge, firefox

        :param browser: The browser to extract the cookies from
        :returns: The extracted cookies
        &#34;&#34;&#34;
        self.cookies = get_browser_cookies(browser)
        return self.cookies

    def set_authkey(self, authkey: str = None) -&gt; None:
        &#34;&#34;&#34;Sets an authkey for wish &amp; transaction logs

        :param authkey: An authkey, a url containing an authkey or a path towards a logfile
        :returns: The new authkey
        &#34;&#34;&#34;
        if authkey is None or os.path.isfile(authkey):
            authkey = get_authkey(authkey)
        else:
            authkey = extract_authkey(authkey) or authkey

        self.authkey = authkey

    def set_cache(
        self,
        maxsize: int,
        strategy: Literal[&#34;FIFO&#34;, &#34;LFU&#34;, &#34;LRU&#34;, &#34;MRU&#34;, &#34;RR&#34;] = &#34;LRU&#34;,
        *,
        ttl: int = None,
        getsizeof: Callable[[Any], float] = None,
    ) -&gt; MutableMapping[Any, Any]:
        &#34;&#34;&#34;Create and set a new cache for http requests

        :param maxsize: The maximum size of the cache
        :param strategy: The cache strategy to use, defaults to Least-Recently-Used
        :param ttl: The time to live of items, only works with LRU caches
        :param getsizeof: Function that gets the size of any objecct, by default everything has size of 1
        :returns: The newly created cache
        &#34;&#34;&#34;
        import cachetools

        if ttl:
            if strategy != &#34;LRU&#34;:
                raise ValueError(&#34;TTL caches must use LRU&#34;)

            self.cache = cachetools.TTLCache(maxsize, ttl, getsizeof=getsizeof)
            return self.cache
        elif strategy == &#34;TTL&#34;:
            raise ValueError(&#34;TTL caches should be set using the ttl kwarg&#34;)

        cls_name = strategy + &#34;Cache&#34;
        if not hasattr(cachetools, cls_name):
            raise ValueError(f&#34;Invalid strategy: {strategy}&#34;)

        self.cache = getattr(cachetools, cls_name)(maxsize, getsizeof=getsizeof)
        return self.cache

    async def _check_cache(
        self,
        key: Tuple[Any, ...],
        check: Callable[[Any], bool] = None,
        *,
        lang: str = None,
    ) -&gt; Optional[Any]:
        &#34;&#34;&#34;Check the cache for any entries&#34;&#34;&#34;
        if self.cache is None:
            return None

        key = key + (lang or self.lang,)

        if key not in self.cache:
            return None

        data = self.cache[key]
        if check is None or check(data):
            return data

        del self.cache[key]

        return None

    async def _update_cache(
        self,
        data: Any,
        key: Tuple[Any, ...],
        check: Callable[[Any], bool] = None,
        *,
        lang: str = None,
    ) -&gt; None:
        &#34;&#34;&#34;Update the cache with a new entry&#34;&#34;&#34;
        if self.cache is None:
            return

        key = key + (lang or self.lang,)

        if check is not None and not check(data):
            return

        self.cache[key] = data

    async def _request_hook(
        self,
        method: str,
        url: Union[str, URL],
        *,
        params: Dict[str, Any] = None,
        json: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;A hook before request, by default performs a debug log&#34;&#34;&#34;
        url = URL(url)
        if params:
            params = {k: v for k, v in params.items() if k != &#34;authkey&#34;}
            url = url.with_query(params)

        string = f&#34;{method} {url}&#34;
        if json:
            string += &#34;\n&#34; + json_.dumps(json, separators=(&#34;,&#34;, &#34;:&#34;))

        self.logger.debug(string)

    # ASYNCIO HANDLERS:

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the underlying aiohttp session&#34;&#34;&#34;
        if not self.session.closed:
            await self.session.close()

    async def __aenter__(self):
        return self

    async def __aexit__(self, *exc_info):
        await self.close()

    # RAW HTTP REQUESTS:

    @handle_ratelimits()
    async def request(
        self,
        url: Union[str, URL],
        method: str = &#34;GET&#34;,
        *,
        headers: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request and return a parsed json response&#34;&#34;&#34;
        asyncio.create_task(self._fetch_mi18n())

        headers = headers or {}
        headers[&#34;User-Agent&#34;] = self.USER_AGENT

        await self._request_hook(method, url, headers=headers, **kwargs)

        async with self.session.request(method, url, headers=headers, **kwargs) as r:
            r.raise_for_status()
            data = await r.json()

        if data[&#34;retcode&#34;] == 0:
            return data[&#34;data&#34;]

        errors.raise_for_retcode(data)

    async def request_webstatic(
        self,
        url: Union[str, URL],
        *,
        headers: Dict[str, Any] = None,
        cache: bool = True,
        **kwargs: Any,
    ) -&gt; Any:
        &#34;&#34;&#34;Request a static json file&#34;&#34;&#34;
        url = URL(self.WEBSTATIC_URL).join(URL(url))

        data = get_from_static_cache(str(url))
        if data is not None:
            return data

        headers = headers or {}
        headers[&#34;user-agent&#34;] = self.USER_AGENT

        async with self.session.get(url, headers=headers, **kwargs) as r:
            r.raise_for_status()
            data = await r.json()

        if cache:
            save_to_static_cache(str(url), data)

        return data

    async def request_hoyolab(
        self,
        endpoint: Union[str, URL],
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        cache: Tuple[Any, ...] = None,
        cache_check: Callable[[Any], bool] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards misc hoyolabs api

        Community related data
        &#34;&#34;&#34;
        if cache:
            data = await self._check_cache(cache, cache_check, lang=lang)
            if data:
                return data

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)
        if lang not in LANGS and lang is not None:
            raise ValueError(f&#34;{lang} is not a valid language, must be one of: &#34; + &#34;, &#34;.join(LANGS))

        url = URL(self.TAKUMI_URL).join(URL(endpoint))

        headers = {
            &#34;x-rpc-app_version&#34;: &#34;1.5.0&#34;,
            &#34;x-rpc-client_type&#34;: &#34;4&#34;,
            &#34;x-rpc-language&#34;: lang or self.lang,
            &#34;ds&#34;: generate_dynamic_secret(self.DS_SALT),
        }

        data = await self.request(url, method, headers=headers, **kwargs)

        if cache:
            await self._update_cache(data, cache, cache_check, lang=lang)

        return data

    async def request_game_record(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        cache: Tuple[Any, ...] = None,
        cache_check: Callable[[Any], bool] = None,
        **kwargs: Any,
    ):
        &#34;&#34;&#34;Make a request towards the game record endpoint

        User stats related data
        &#34;&#34;&#34;
        # this is simply just an alias for shorter request endpoints
        url = URL(self.RECORD_URL).join(URL(endpoint))

        return await self.request_hoyolab(
            url, method=method, cache=cache, cache_check=cache_check, **kwargs
        )

    async def request_ledger(
        self,
        uid: int = None,
        detail: bool = False,
        *,
        month: int = None,
        lang: str = None,
        params: Dict[str, Any] = None,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the ys ledger endpoint

        Traveler&#39;s diary related data
        &#34;&#34;&#34;
        params = params or {}

        url = URL(self.DETAIL_LEDGER_URL if detail else self.INFO_LEDGER_URL)

        params.update(await self._complete_uid(uid))
        params[&#34;month&#34;] = month or datetime.now().month
        params[&#34;lang&#34;] = lang or self.lang

        return await self.request(url, params=params)

    async def request_calculator(
        self,
        endpoint: str,
        *,
        method: str = &#34;POST&#34;,
        lang: str = None,
        params: Dict[str, Any] = None,
        json: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the calculator endpoint

        Calculator database and resource calculation
        &#34;&#34;&#34;
        params = params or {}
        json = json or {}

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.CALCULATOR_URL).join(URL(endpoint))

        if method == &#34;GET&#34;:
            params[&#34;lang&#34;] = lang or self.lang
            json = None
        else:
            json[&#34;lang&#34;] = lang or self.lang

        return await self.request(url, method, params=params, json=json, **kwargs)

    async def request_daily_reward(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the daily reward endpoint

        Daily reward claiming and history
        &#34;&#34;&#34;
        params = params or {}

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.REWARD_URL).join(URL(endpoint))

        params[&#34;lang&#34;] = lang or self.lang
        params[&#34;act_id&#34;] = self.ACT_ID

        return await self.request(url, method, params=params, **kwargs)

    async def request_gacha_info(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        authkey: Optional[str] = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the game info endpoint

        Wish history related data
        &#34;&#34;&#34;
        params = params or {}
        authkey = authkey or self.authkey

        if authkey is None:
            raise RuntimeError(&#34;No authkey provided&#34;)

        base_url = URL(self.GACHA_INFO_URL)
        url = base_url.join(URL(endpoint))

        params[&#34;authkey_ver&#34;] = 1
        params[&#34;authkey&#34;] = unquote(authkey)
        params[&#34;lang&#34;] = create_short_lang_code(lang or self.lang)

        return await self.request(url, method, params=params, **kwargs)

    async def request_transaction(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        authkey: Optional[str] = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the transaction log endpoint

        Transaction related data
        &#34;&#34;&#34;
        params = params or {}
        authkey = authkey or self.authkey

        if authkey is None:
            raise RuntimeError(&#34;No authkey provided&#34;)

        base_url = URL(self.YSULOG_URL)
        url = base_url.join(URL(endpoint))

        params[&#34;authkey_ver&#34;] = 1
        params[&#34;sign_type&#34;] = 2
        params[&#34;authkey&#34;] = unquote(authkey)
        params[&#34;lang&#34;] = create_short_lang_code(lang or self.lang)

        return await self.request(url, method, params=params, **kwargs)

    async def request_map(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        map_id: int = 2,
        static: bool = False,
        params: Dict[str, Any] = None,
        **kwargs,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the map endpoint

        Interactive map related data
        &#34;&#34;&#34;
        params = params or {}

        base_url = self.STATIC_MAP_URL if static else self.MAP_URL
        url = URL(base_url).join(URL(endpoint))

        params[&#34;map_id&#34;] = map_id
        params[&#34;app_sn&#34;] = &#34;ys_obc&#34;
        params[&#34;lang&#34;] = lang or self.lang

        return await self.request(url, method, params=params, **kwargs)

    async def login_with_ticket(self, login_ticket: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Complete cookies using a login ticket&#34;&#34;&#34;
        url = &#34;https://webapi-os.account.hoyoverse.com/Api/cookie_accountinfo_by_loginticket&#34;
        async with self.session.get(url, params=dict(login_ticket=login_ticket)) as r:
            r.raise_for_status()

    # HOYOLAB:

    async def genshin_accounts(self, *, lang: str = None) -&gt; List[GenshinAccount]:
        &#34;&#34;&#34;Get the genshin accounts of the currently logged-in user

        :params lang: The language to use
        &#34;&#34;&#34;
        # TODO: Account for honkai accounts

        # fmt: off
        data = await self.request_hoyolab(
            &#34;binding/api/getUserGameRolesByCookie&#34;,
            lang=lang,
            cache=(&#34;accounts&#34;, self.hoyolab_uid)
        )
        # fmt: on
        return [GenshinAccount(**i) for i in data[&#34;list&#34;]]

    async def search_users(self, keyword: str, *, lang: str = None) -&gt; List[SearchUser]:
        &#34;&#34;&#34;Search hoyolab users

        :param keyword: The keyword to search with
        :params lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_hoyolab(
            &#34;community/search/wapi/search/user&#34;,
            lang=lang,
            params=dict(keyword=keyword, page_size=20),
            cache=(&#34;search&#34;, keyword),
        )
        return [SearchUser(**i[&#34;user&#34;]) for i in data[&#34;list&#34;]]

    async def set_visibility(self, public: bool) -&gt; None:
        &#34;&#34;&#34;Sets your data to public or private.

        :param public: Whether the data should now be public
        &#34;&#34;&#34;
        await self.request_game_record(
            &#34;genshin/wapi/publishGameRecord&#34;,
            method=&#34;POST&#34;,
            json=dict(is_public=public, game_id=2),
        )

    async def get_recommended_users(self, *, limit: int = 200) -&gt; List[SearchUser]:
        &#34;&#34;&#34;Get a list of recommended active users

        :param limit: The maximum amount of users to return
        &#34;&#34;&#34;
        data = await self.request_hoyolab(
            &#34;community/user/wapi/recommendActive&#34;,
            params=dict(page_size=limit),
        )
        return [SearchUser(**i[&#34;user&#34;]) for i in data[&#34;list&#34;]]

    async def redeem_code(self, code: str, uid: int = None, *, lang: str = None) -&gt; None:
        &#34;&#34;&#34;Redeems a gift code for the current user

        :param code: The code to redeem
        :param uid: The specific uid to redeem for
        :param lang: The language to use
        &#34;&#34;&#34;
        # do note that this endpoint is very quirky, can&#39;t really make this pretty
        if uid is not None:
            server = recognize_server(uid)
            lang = create_short_lang_code(lang or self.lang)
            await self.request(
                &#34;https://hk4e-api-os.hoyoverse.com/common/apicdkey/api/webExchangeCdkey&#34;,
                params=dict(
                    uid=uid,
                    region=server,
                    cdkey=code,
                    game_biz=&#34;hk4e_global&#34;,
                    lang=lang,
                ),
            )
            return

        accounts = [a for a in await self.genshin_accounts() if a.level &gt;= 10]

        for i, account in enumerate(accounts):
            # there&#39;s a ratelimit of 1 request every 5 seconds
            if i:
                await asyncio.sleep(5)

            await self.redeem_code(code, account.uid, lang=lang)

    # GAME RECORD:

    async def _fetch_raw_user(self, uid: int, lang: str = None) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Low-level http method for fetching the game record index&#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/index&#34;,
            lang=lang,
            params=dict(server=server, role_id=uid),
            cache=(&#34;user&#34;, uid),
        )
        return data

    async def _fetch_raw_characters(self, uid: int, *, lang: str = None) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Low-level http method for fetching the game record characters

        Caching with characters is optimized
        &#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/character&#34;,
            method=&#34;POST&#34;,
            lang=lang,
            json=dict(role_id=uid, server=server),
            cache=(&#34;characters&#34;, uid),
        )

        return data[&#34;avatars&#34;]

    async def get_record_card(self, hoyolab_uid: int = None, *, lang: str = None) -&gt; RecordCard:
        &#34;&#34;&#34;Get a user&#39;s record card

        :param hoyolab_uid: A hoyolab uid
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_game_record(
            &#34;card/wapi/getGameRecordCard&#34;,
            lang=lang,
            params=dict(uid=hoyolab_uid or self.hoyolab_uid),
            cache=(&#34;record&#34;, hoyolab_uid),
            cache_check=lambda data: len(data[&#34;list&#34;]) &gt; 0,
        )
        cards = data[&#34;list&#34;]
        if not cards:
            raise errors.DataNotPublic({&#34;retcode&#34;: 10102})

        return RecordCard(**cards[0])

    async def get_user(self, uid: int, *, lang: str = None) -&gt; UserStats:
        &#34;&#34;&#34;Get a user&#39;s stats and characters

        :param uid: A Genshin uid
        :param character_ids: The ids of characters you want to fetch
        :param all_characters: Whether to get every single character a user has. Discouraged.
        :param lang: The language to use
        &#34;&#34;&#34;
        data, characters = await asyncio.gather(
            self._fetch_raw_user(uid, lang=lang),
            self._fetch_raw_characters(uid, lang=lang),
        )
        data[&#34;avatars&#34;] = characters

        return UserStats(**data)

    async def get_partial_user(self, uid: int, *, lang: str = None) -&gt; PartialUserStats:
        &#34;&#34;&#34;Helper function to get a user without any equipment

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._fetch_raw_user(uid, lang=lang)
        return PartialUserStats(**data)

    async def get_characters(self, uid: int, *, lang: str = None) -&gt; List[Character]:
        &#34;&#34;&#34;Helper function to fetch characters from just their ids

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._fetch_raw_characters(uid, lang=lang)
        return [Character(**i) for i in data]

    async def get_spiral_abyss(
        self, uid: int, *, previous: bool = False, lang: str = None
    ) -&gt; SpiralAbyss:
        &#34;&#34;&#34;Get spiral abyss runs

        :param uid: A Genshin uid
        :param previous: Whether to get the record of the previous spiral abyss
        :param lang: The language to use
        &#34;&#34;&#34;
        server = recognize_server(uid)
        schedule_type = 2 if previous else 1
        data = await self.request_game_record(
            &#34;genshin/api/spiralAbyss&#34;,
            lang=lang,
            params=dict(role_id=uid, server=server, schedule_type=schedule_type),
            cache=(&#34;abyss&#34;, uid, schedule_type),
        )
        return SpiralAbyss(**data)

    async def get_notes(self, uid: int, *, lang: str = None) -&gt; Notes:
        &#34;&#34;&#34;Get the real-time notes.

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/dailyNote&#34;,
            lang=lang,
            params=dict(server=server, role_id=uid),
        )
        return Notes(**data)

    async def get_activities(self, uid: int, *, lang: str = None) -&gt; Activities:
        &#34;&#34;&#34;Get activities

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/activities&#34;,
            lang=lang,
            params=dict(server=server, role_id=uid),
            cache=(&#34;activities&#34;, uid),
        )
        return Activities(**data)

    async def get_full_user(self, uid: int, *, lang: str = None) -&gt; FullUserStats:
        &#34;&#34;&#34;Get a user with all their possible data

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        user, abyss1, abyss2, activities = await asyncio.gather(
            self.get_user(uid, lang=lang),
            self.get_spiral_abyss(uid, lang=lang, previous=False),
            self.get_spiral_abyss(uid, lang=lang, previous=True),
            self.get_activities(uid, lang=lang),
        )
        abyss = {&#34;current&#34;: abyss1, &#34;previous&#34;: abyss2}
        return FullUserStats(**user.dict(), abyss=abyss, activities=activities)

    async def set_top_characters(self, character_ids: List[int], *, uid: int = None) -&gt; None:
        &#34;&#34;&#34;Set the top 8 visible characters for the current user

        :param character_ids: IDs of characters to be shown
        :param uid: Genshin uid of the currently logged-in user
        &#34;&#34;&#34;
        json = dict(avatar_ids=character_ids)
        json.update(await self._complete_uid(uid, uid_key=&#34;role_id&#34;, server_key=&#34;server&#34;))
        await self.request_game_record(
            &#34;genshin/api/character/top&#34;,
            method=&#34;POST&#34;,
            json=json,
        )

    # LEDGER:

    async def get_diary(self, uid: int = None, *, month: int = None, lang: str = None) -&gt; Diary:
        &#34;&#34;&#34;Get a traveler&#39;s diary with earning details for the month

        :param uid: Genshin uid of the currently logged-in user
        :param month: The month in the year to see the history for
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_ledger(uid, month=month, lang=lang)
        return Diary(**data)

    def diary_log(
        self,
        uid: int = None,
        *,
        mora: bool = False,
        month: int = None,
        limit: int = None,
        lang: str = None,
    ) -&gt; DiaryPaginator:
        &#34;&#34;&#34;Create a new daily reward pagintor

        :param client: A client for making http requests
        :param uid: Genshin uid of the currently logged-in user
        :param mora: Whether the type of currency should be mora instead of primogems
        :param month: The month in the year to see the history for
        :param limit: The maximum amount of actions to get
        :param lang: The language to use
        &#34;&#34;&#34;
        type = 2 if mora else 1
        return DiaryPaginator(self, uid, type, month, limit, lang)

    # CALCULATOR

    def calculator(self, *, lang: str = None) -&gt; CalculatorBuilder:
        &#34;&#34;&#34;Calculate the resources needed to level up various equipment.

        :param lang: The language to use
        &#34;&#34;&#34;
        return CalculatorBuilder(self, lang=lang)

    async def _execute_calculator(self, builder: CalculatorBuilder) -&gt; CalculatorResult:
        &#34;&#34;&#34;Create a request to calculate the results of a builder&#34;&#34;&#34;
        json = await builder.build()
        data = await self.request_calculator(&#34;compute&#34;, lang=builder.lang, json=json)
        return CalculatorResult(**data)

    async def _get_calculator_items(
        self,
        slug: str,
        filters: Dict[str, Any],
        query: str = None,
        *,
        is_all: bool = False,
        sync: Union[int, bool] = False,
        lang: str = None,
    ) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Get all items of a specific slug from a calculator&#34;&#34;&#34;
        if query and any(isinstance(v, list) and v for v in filters.values()):
            raise TypeError(&#34;Cannot specify a query and filter at the same time&#34;)

        endpoint = f&#34;sync/{slug}/list&#34; if sync else f&#34;{slug}/list&#34;
        json: Dict[str, Any] = dict(page=1, size=69420, is_all=is_all, **filters)
        if query:
            json.update(keywords=query)
        if sync:
            json.update(await self._complete_uid(sync if sync &gt; 1 else None))

        data = await self.request_calculator(
            endpoint,
            lang=lang,
            json=json,
        )
        return data[&#34;list&#34;]

    async def get_calculator_characters(
        self,
        *,
        query: str = None,
        elements: Sequence[int] = None,
        weapon_types: Sequence[int] = None,
        include_traveler: bool = False,
        sync: Union[int, bool] = False,
        lang: str = None,
    ) -&gt; List[CalculatorCharacter]:
        &#34;&#34;&#34;Get all characters provided by the Enhancement Progression Calculator

        :param query: A query to use when searching; incompatible with other filters
        :param elements: The elements of returned characters - refer to `.models.CALCULATOR_ELEMENTS`
        :param weapon_types: The weapon types of returned characters - refer to `.models.CALCULATOR_WEAPON_TYPES`
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._get_calculator_items(
            &#34;avatar&#34;,
            lang=lang,
            is_all=include_traveler,
            sync=sync,
            query=query,
            filters=dict(
                element_attr_ids=elements or [],
                weapon_cat_ids=weapon_types or [],
            ),
        )
        return [CalculatorCharacter(**i) for i in data]

    async def get_calculator_weapons(
        self,
        *,
        query: str = None,
        types: Sequence[int] = None,
        rarities: Sequence[int] = None,
        lang: str = None,
    ) -&gt; List[CalculatorWeapon]:
        &#34;&#34;&#34;Get all weapons provided by the Enhancement Progression Calculator

        :param query: A query to use when searching; incompatible with other filters
        :param types: The types of returned weapons - refer to `.models.CALCULATOR_WEAPON_TYPES`
        :param rarities: The rarities of returned weapons
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._get_calculator_items(
            &#34;weapon&#34;,
            lang=lang,
            query=query,
            filters=dict(
                weapon_cat_ids=types or [],
                weapon_levels=rarities or [],
            ),
        )
        return [CalculatorWeapon(**i) for i in data]

    async def get_calculator_artifacts(
        self,
        *,
        query: str = None,
        pos: int = 1,
        rarities: Sequence[int] = None,
        lang: str = None,
    ) -&gt; List[CalculatorArtifact]:
        &#34;&#34;&#34;Get all artifacts provided by the Enhancement Progression Calculator

        :param query: A query to use when searching; incompatible with other filters
        :param pos: The slot position of the returned weapon
        :param rarities: The rarities of returned artifacts
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._get_calculator_items(
            &#34;reliquary&#34;,
            lang=lang,
            query=query,
            filters=dict(
                reliquary_cat_id=pos,
                reliquary_levels=rarities or [],
            ),
        )
        return [CalculatorArtifact(**i) for i in data]

    async def get_character_details(
        self,
        character_id: int,
        *,
        uid: int = None,
        lang: str = None,
    ) -&gt; CalculatorCharacterDetails:
        &#34;&#34;&#34;Get the weapon, artifacts and talents of a character

        Not related to the Battle Chronicle. This data is always private.

        :param lang: The language to use
        &#34;&#34;&#34;
        params = dict(avatar_id=character_id)
        params.update(await self._complete_uid(uid))

        data = await self.request_calculator(
            &#34;sync/avatar/detail&#34;,
            method=&#34;GET&#34;,
            lang=lang,
            params=params,
        )
        return CalculatorCharacterDetails(**data)

    async def get_character_talents(
        self,
        character_id: int,
        *,
        lang: str = None,
    ) -&gt; List[CalculatorTalent]:
        &#34;&#34;&#34;Get the talents of a character

        This only gets the talent names, not their levels.
        Use `get_character_details` for precise information.

        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_calculator(
            &#34;avatar/skill_list&#34;,
            method=&#34;GET&#34;,
            lang=lang,
            params=dict(avatar_id=character_id),
        )
        return [CalculatorTalent(**i) for i in data[&#34;list&#34;]]

    async def get_complete_artifact_set(
        self,
        artifact_id: int,
        *,
        lang: str = None,
    ) -&gt; List[CalculatorArtifact]:
        &#34;&#34;&#34;Get all other artifacts that share a set with any given artifact

        Doesn&#39;t return the artifact passed into this function.

        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_calculator(
            &#34;reliquary/set&#34;,
            method=&#34;GET&#34;,
            lang=lang,
            params=dict(reliquary_id=artifact_id),
        )
        return [CalculatorArtifact(**i) for i in data[&#34;reliquary_list&#34;]]

    # DAILY REWARDS:

    async def get_reward_info(self, *, lang: str = None) -&gt; DailyRewardInfo:
        &#34;&#34;&#34;Get the daily reward info for the current user

        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_daily_reward(&#34;info&#34;, lang=lang)
        return DailyRewardInfo(data[&#34;is_sign&#34;], data[&#34;total_sign_day&#34;])

    async def get_monthly_rewards(self, *, lang: str = None) -&gt; List[DailyReward]:
        &#34;&#34;&#34;Get a list of all availible rewards for the current month

        :param lang: The language to use
        &#34;&#34;&#34;
        func = perm_cache(
            (&#34;rewards&#34;, datetime.utcnow().month, lang or self.lang),
            self.request_daily_reward,
        )
        data = await func(&#34;home&#34;, lang=lang)
        return [DailyReward(**i) for i in data[&#34;awards&#34;]]

    def claimed_rewards(self, *, limit: int = None, lang: str = None) -&gt; DailyRewardPaginator:
        &#34;&#34;&#34;Get all claimed rewards for the current user

        NOTE: Languages are currently broken,
        the language is based off the language used to claim the reward

        :param limit: The maximum amount of rewards to get
        :param lang: The language to use - currently broken
        &#34;&#34;&#34;
        return DailyRewardPaginator(self, limit=limit, lang=lang)

    @overload
    async def claim_daily_reward(
        self, *, lang: str = None, reward: Literal[True] = ...
    ) -&gt; DailyReward:
        ...

    @overload
    async def claim_daily_reward(self, *, lang: str = None, reward: Literal[False]) -&gt; None:
        ...

    async def claim_daily_reward(
        self, *, lang: str = None, reward: bool = True
    ) -&gt; Optional[DailyReward]:
        &#34;&#34;&#34;Signs into hoyolab and claims the daily reward.

        :param lang: The language to use
        :param reward: Whether to also fetch the claimed reward
        &#34;&#34;&#34;
        await self.request_daily_reward(&#34;sign&#34;, method=&#34;POST&#34;, lang=lang)

        if not reward:
            return None

        info, rewards = await asyncio.gather(
            self.get_reward_info(lang=lang),
            self.get_monthly_rewards(lang=lang),
        )
        return rewards[info.claimed_rewards - 1]

    # WISH HISTORY:

    @overload
    def wish_history(
        self,
        banner_type: Optional[List[BannerType]] = ...,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; MergedWishHistory:
        ...

    @overload
    def wish_history(
        self,
        banner_type: BannerType,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; WishHistory:
        ...

    def wish_history(
        self,
        banner_type: Union[BannerType, List[BannerType]] = None,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Union[WishHistory, MergedWishHistory]:
        &#34;&#34;&#34;Get the wish history of a user

        :param banner_type: The banner(s) from which to get the wishes
        :param limit: The maximum amount of wishes to get
        :param lang: The language to use
        :param authkey: The authkey to use when requesting data
        :param end_id: The ending id to start getting data from
        &#34;&#34;&#34;
        cls = WishHistory if isinstance(banner_type, int) else MergedWishHistory
        return cls(
            self,
            banner_type,  # type: ignore
            lang=lang,
            authkey=authkey,
            limit=limit,
            end_id=end_id,
        )

    async def get_banner_names(
        self, *, lang: str = None, authkey: str = None
    ) -&gt; Dict[BannerType, str]:
        &#34;&#34;&#34;Get a list of banner names

        :param lang: The language to use
        :param authkey: The authkey to use when requesting data
        &#34;&#34;&#34;
        func = perm_cache((&#34;banners&#34;, lang or self.lang), self.request_gacha_info)
        data = await func(
            &#34;getConfigList&#34;,
            lang=lang,
            authkey=authkey,
        )
        return {int(i[&#34;key&#34;]): i[&#34;name&#34;] for i in data[&#34;gacha_type_list&#34;]}  # type: ignore

    async def _get_banner_details(self, banner_id: str, *, lang: str = None) -&gt; BannerDetails:
        &#34;&#34;&#34;Get details of a specific banner using its id

        :param banner_id: A banner id
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_webstatic(
            f&#34;/hk4e/gacha_info/os_asia/{banner_id}/{lang or self.lang}.json&#34;
        )
        return BannerDetails(**data, banner_id=banner_id)

    async def get_banner_details(
        self, banner_ids: List[str] = None, *, lang: str = None
    ) -&gt; List[BannerDetails]:
        &#34;&#34;&#34;Get all banner details at once in a batch

        :param banner_ids: A list of banner ids, implicitly fetched when not provided
        :param lang: The language to use
        &#34;&#34;&#34;
        try:
            banner_ids = banner_ids or get_banner_ids()
        except FileNotFoundError:
            banner_ids = []

        if len(banner_ids) &lt; 3:
            banner_ids = await self.fetch_banner_ids()

        data = await asyncio.gather(*(self._get_banner_details(i, lang=lang) for i in banner_ids))
        return list(data)

    async def get_gacha_items(
        self, *, server: str = &#34;os_asia&#34;, lang: str = None
    ) -&gt; List[GachaItem]:
        &#34;&#34;&#34;Get the list of characters and weapons that can be gotten from the gacha.

        :param server: The server to request the items from
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_webstatic(
            f&#34;/hk4e/gacha_info/{server}/items/{lang or self.lang}.json&#34;, cache=False
        )
        return [GachaItem(**i) for i in data]

    # TRANSACTIONS:

    async def _get_transaction_reasons(self, lang: str) -&gt; Dict[str, str]:
        &#34;&#34;&#34;Get a mapping of transaction reasons

        :param lang: The language to use
        &#34;&#34;&#34;
        base = &#34;https://mi18n-os.hoyoverse.com/webstatic/admin/mi18n/hk4e_global/&#34;
        data = await self.request_webstatic(base + f&#34;m02251421001311/m02251421001311-{lang}.json&#34;)

        return {
            k.split(&#34;_&#34;)[-1]: v
            for k, v in data.items()
            if k.startswith(&#34;selfinquiry_general_reason_&#34;)
        }

    @overload
    def transaction_log(
        self,
        kind: Optional[List[TransactionKind]] = ...,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; MergedTransactions:
        ...

    @overload
    def transaction_log(
        self,
        kind: Literal[&#34;primogem&#34;, &#34;crystal&#34;, &#34;resin&#34;],
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Transactions[Transaction]:
        ...

    @overload
    def transaction_log(
        self,
        kind: Literal[&#34;artifact&#34;, &#34;weapon&#34;],
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Transactions[ItemTransaction]:
        ...

    def transaction_log(
        self,
        kind: Union[TransactionKind, List[TransactionKind]] = None,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Union[Transactions[Any], MergedTransactions]:
        &#34;&#34;&#34;Get the transaction log of a user

        :param kind: The kind(s) of transactions to get
        :param limit: The maximum amount of wishes to get
        :param lang: The language to use
        :param authkey: The authkey to use when requesting data
        :param end_id: The ending id to start getting data from
        &#34;&#34;&#34;
        cls = Transactions if isinstance(kind, str) else MergedTransactions
        return cls(
            self,
            kind,  # type: ignore
            lang=lang,
            authkey=authkey,
            limit=limit,
            end_id=end_id,
        )

    # INTERACTIVE MAP:

    async def _get_map_pin_icons(self, map_id: int = 2, *, lang: str = None) -&gt; Dict[int, str]:
        &#34;&#34;&#34;Get the icons of pins&#34;&#34;&#34;
        data = await self.request_map(&#34;spot_kind/get_icon_list&#34;, lang=lang, map_id=map_id)
        return {i[&#34;id&#34;]: i[&#34;url&#34;] for i in data[&#34;icons&#34;]}

    async def get_map_info(self, map_id: int = 2, *, lang: str = None) -&gt; MapInfo:
        &#34;&#34;&#34;Get info about an interactive map&#34;&#34;&#34;
        data = await self.request_map(
            &#34;map/info&#34;,
            lang=lang,
            map_id=map_id,
            static=True,
        )
        return MapInfo(**data[&#34;info&#34;])

    async def get_map_labels(self, map_id: int = 2, *, lang: str = None) -&gt; List[MapNode]:
        &#34;&#34;&#34;Get the map tree of all categories &amp; lables of map points

        :param map_id: The id of the map
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_map(&#34;map/label/tree&#34;, lang=lang, map_id=map_id, static=True)
        return [MapNode(**i) for i in data[&#34;tree&#34;]]

    async def get_map_points(
        self, map_id: int = 2, *, lang: str = None
    ) -&gt; Tuple[List[MapNode], List[MapPoint]]:
        &#34;&#34;&#34;Get a tuple of all map lables and map points

        :param map_id: The id of the map
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_map(&#34;map/point/list&#34;, lang=lang, map_id=map_id, static=True)

        labels = [MapNode(**i) for i in data[&#34;label_list&#34;]]
        points = [MapPoint(**i) for i in data[&#34;point_list&#34;]]

        return labels, points

    async def get_map_locations(self, map_id: int = 2, *, lang: str = None) -&gt; List[MapLocation]:
        &#34;&#34;&#34;Get a list of all locations on a map

        :param map_id: The id of the map
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_map(&#34;map/map_anchor/list&#34;, lang=lang, map_id=map_id, static=True)

        return [MapLocation(**i) for i in data[&#34;list&#34;]]

    # MISC:

    async def _complete_uid(
        self,
        uid: Optional[int] = None,
        uid_key: str = &#34;uid&#34;,
        server_key: str = &#34;region&#34;,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Create a new dict with a uid and a server

        These are fetched from the currently authenticated user
        &#34;&#34;&#34;
        params: Dict[str, Any] = {}

        uid = uid or self._uid

        if uid is None:
            accounts = await self.genshin_accounts()
            # filter test servers
            accounts = [
                account for account in accounts if &#34;os&#34; in account.server or &#34;cn&#34; in account.server
            ]

            # TODO: Raise properly
            if not accounts:
                errors.raise_for_retcode({&#34;retcode&#34;: -1073})

            account = max(accounts, key=lambda a: a.level)
            uid = account.uid

            self._uid = uid

        params[uid_key] = uid
        params[server_key] = recognize_server(uid)

        return params

    async def _fetch_mi18n(self) -&gt; Dict[str, Dict[str, str]]:
        if self.fetched_mi18n:
            return GenshinModel._mi18n

        self.fetched_mi18n = True

        async def single(url: str, key: str, lang: str = None):
            if lang is None:
                coros = (single(url, key, l) for l in LANGS)
                return await asyncio.gather(*coros)

            data = await self.request_webstatic(url.format(lang=lang))
            for k, v in data.items():
                GenshinModel._mi18n.setdefault(key + &#34;/&#34; + k, {})[lang] = v

        coros = (single(url, key) for key, url in GenshinModel._mi18n_urls.items())
        await asyncio.gather(*coros)

        return GenshinModel._mi18n

    async def init(self, lang: str = None):
        &#34;&#34;&#34;Request all static &amp; permanent endpoints to not require them later

        :param lang: The language to use
        &#34;&#34;&#34;
        lang = lang or self.lang

        await asyncio.gather(
            self.get_banner_names(lang=lang),
            self.get_banner_details(lang=lang),
            self.get_monthly_rewards(),
            self._get_transaction_reasons(lang=lang),
            self._fetch_mi18n(),
        )

    async def fetch_banner_ids(self) -&gt; List[str]:
        &#34;&#34;&#34;Fetch banner ids from a user-mantained repo&#34;&#34;&#34;
        url = &#34;https://raw.githubusercontent.com/thesadru/genshindata/master/banner_ids.txt&#34;
        async with self.session.get(url) as r:
            data = await r.text()
        return data.splitlines()


class ChineseClient(GenshinClient):
    &#34;&#34;&#34;A Genshin Client for chinese endpoints&#34;&#34;&#34;

    DS_SALT = &#34;xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs&#34;
    SIGNIN_SALT = &#34;4a8knnbk5pbjqsrudp3dq484m9axoc5g&#34;
    ACT_ID = &#34;e202009291139501&#34;

    TAKUMI_URL = &#34;https://api-takumi.mihoyo.com/&#34;
    RECORD_URL = &#34;https://api-takumi-record.mihoyo.com/game_record/app/&#34;
    INFO_LEDGER_URL = &#34;https://hk4e-api.mihoyo.com/event/ys_ledger/monthInfo&#34;
    DETAIL_LEDGER_URL = &#34;https://hk4e-api.mihoyo.com/event/ys_ledger/monthDetail&#34;
    REWARD_URL = &#34;https://api-takumi.mihoyo.com/event/bbs_sign_reward/&#34;
    GACHA_INFO_URL = &#34;https://hk4e-api.mihoyo.com/event/gacha_info/api/&#34;
    MAP_URL = &#34;https://api-takumi-static.mihoyo.com/common/map_user/ys_obc/v1/map/&#34;
    STATIC_MAP_URL = &#34;https://api-static.mihoyo.com/common/map_user/ys_obc/v1/map&#34;

    def __init__(
        self,
        cookies: Mapping[str, str] = None,
        authkey: str = None,
        *,
        lang: str = &#34;zh-tw&#34;,
        debug: bool = False,
    ) -&gt; None:
        super().__init__(cookies=cookies, authkey=authkey, lang=lang, debug=debug)

    async def request_hoyolab(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        json: Any = None,
        params: Dict[str, Any] = None,
        cache: Tuple[Any, ...] = None,
        cache_check: Callable[[Any], bool] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        kwargs.pop(&#34;lang&#34;, None)
        params = params or {}

        if cache:
            data = await self._check_cache(cache, cache_check)
            if data:
                return data

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.TAKUMI_URL).join(URL(endpoint))

        # all of this repetition is literally just to change these few lines
        headers = {
            &#34;x-rpc-app_version&#34;: &#34;2.11.1&#34;,
            &#34;x-rpc-client_type&#34;: &#34;5&#34;,
            &#34;ds&#34;: generate_cn_dynamic_secret(self.DS_SALT, json, params),
        }

        data = await self.request(url, method, headers=headers, json=json, params=params, **kwargs)

        if cache:
            await self._update_cache(data, cache, cache_check)

        return data

    async def request_ledger(
        self,
        uid: int = None,
        detail: bool = False,
        *,
        month: int = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the ys ledger endpoint

        Traveler&#39;s diary related data
        &#34;&#34;&#34;
        kwargs.pop(&#34;lang&#34;, None)
        params = params or {}

        url = URL(self.DETAIL_LEDGER_URL if detail else self.INFO_LEDGER_URL)

        params.update(await self._complete_uid(uid, &#34;bind_uid&#34;, &#34;bind_region&#34;))
        params[&#34;month&#34;] = month or datetime.now().month

        return await self.request(url, params=params)

    async def request_daily_reward(
        self,
        endpoint: str,
        uid: int = None,
        *,
        method: str = &#34;GET&#34;,
        params: Dict[str, Any] = None,
        headers: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        kwargs.pop(&#34;lang&#34;, None)
        headers = headers or {}
        params = params or {}

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.REWARD_URL).join(URL(endpoint))

        params.update(await self._complete_uid(uid))

        headers[&#34;x-rpc-app_version&#34;] = &#34;2.10.1&#34;
        headers[&#34;x-rpc-client_type&#34;] = &#34;5&#34;
        headers[&#34;x-rpc-device_id&#34;] = str(uuid.uuid4())
        headers[&#34;ds&#34;] = generate_dynamic_secret(self.SIGNIN_SALT)

        params[&#34;act_id&#34;] = self.ACT_ID

        return await self.request(url, method, params=params, headers=headers, **kwargs)

    async def get_reward_info(self, uid: int = None) -&gt; DailyRewardInfo:
        &#34;&#34;&#34;Get the daily reward info for the current user

        :param uid: Genshin uid of the currently logged-in user
        &#34;&#34;&#34;
        data = await self.request_daily_reward(&#34;info&#34;, uid)
        return DailyRewardInfo(data[&#34;is_sign&#34;], data[&#34;total_sign_day&#34;])

    async def get_monthly_rewards(self) -&gt; List[DailyReward]:
        &#34;&#34;&#34;Get a list of all availible rewards for the current month&#34;&#34;&#34;
        # uid doesn&#39;t matter, this is a static resource
        func = perm_cache(
            (&#34;cn_rewards&#34;, datetime.utcnow().month),
            self.request_daily_reward,
        )
        data = await func(&#34;home&#34;, uid=1)
        return [DailyReward(**i) for i in data[&#34;awards&#34;]]

    def claimed_rewards(self, uid: int = None, *, limit: int = None) -&gt; ChineseDailyRewardPaginator:
        &#34;&#34;&#34;Get all claimed rewards for the current user

        NOTE: Languages are currently broken,
        the language is based off the language used to claim the reward

        :param limit: The maximum amount of rewards to get
        :param lang: The language to use - currently broken
        &#34;&#34;&#34;
        return ChineseDailyRewardPaginator(self, uid, limit=limit)

    @overload
    async def claim_daily_reward(
        self, uid: int = None, *, reward: Literal[True] = ...
    ) -&gt; DailyReward:
        ...

    @overload
    async def claim_daily_reward(self, uid: int = None, *, reward: Literal[False]) -&gt; None:
        ...

    async def claim_daily_reward(
        self, uid: int = None, *, reward: bool = True
    ) -&gt; Optional[DailyReward]:
        &#34;&#34;&#34;Signs into hoyolab and claims the daily reward.

        :param uid: Genshin uid of the currently logged-in user
        :param reward: Whether to also fetch the claimed reward
        &#34;&#34;&#34;
        await self.request_daily_reward(&#34;sign&#34;, uid, method=&#34;POST&#34;)

        if not reward:
            return None

        info, rewards = await asyncio.gather(
            self.get_reward_info(),
            self.get_monthly_rewards(),
        )
        return rewards[info.claimed_rewards - 1]


class MultiCookieClient(GenshinClient):
    &#34;&#34;&#34;A Genshin Client which allows setting multiple cookies&#34;&#34;&#34;

    sessions: List[aiohttp.ClientSession]

    def __init__(
        self,
        cookie_list: Iterable[Mapping[str, str]] = None,
        *,
        lang: str = &#34;en-us&#34;,
        debug: bool = False,
    ) -&gt; None:
        self.sessions = []

        if cookie_list:
            self.set_cookies(cookie_list)

        super().__init__(lang=lang, debug=debug)

    @property
    def session(self) -&gt; aiohttp.ClientSession:
        &#34;&#34;&#34;The currently chosen session&#34;&#34;&#34;
        if not self.sessions:
            return aiohttp.ClientSession()

        return self.sessions[0]

    @property
    def cookies(self) -&gt; List[Mapping[str, str]]:
        &#34;&#34;&#34;A list of all cookies&#34;&#34;&#34;
        return [{m.key: m.value for m in s.cookie_jar} for s in self.sessions]

    @cookies.setter
    def cookies(self, cookies: List[Mapping[str, Any]]) -&gt; None:
        self.set_cookies(cookies)

    def set_cookies(
        self,
        cookie_list: Union[Iterable[Union[Mapping[str, Any], str]], str],
        clear: bool = True,
    ) -&gt; List[Mapping[str, str]]:
        &#34;&#34;&#34;Set a list of cookies

        :param cookie_list: A list of cookies or a json file containing cookies
        :param clear: Whether to clear all of the previous cookies
        &#34;&#34;&#34;
        if clear:
            self.sessions.clear()

        if isinstance(cookie_list, str):
            with open(cookie_list) as file:
                cookie_list = json_.load(file)

            if not isinstance(cookie_list, list):
                raise RuntimeError(&#34;Json file must contain a list of cookies&#34;)

        for cookies in cookie_list:
            session = aiohttp.ClientSession(cookies=SimpleCookie(cookies))
            self.sessions.append(session)

        return self.cookies

    def set_browser_cookies(self, *args: Any, **kwargs: Any) -&gt; NoReturn:
        raise RuntimeError(f&#34;{type(self).__name__} does not support browser cookies&#34;)

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the underlying aiohttp sessions&#34;&#34;&#34;
        tasks = [
            asyncio.create_task(session.close()) for session in self.sessions if not session.closed
        ]
        if tasks:
            await asyncio.wait(tasks)

        await super().close()

    async def request(
        self,
        url: Union[str, URL],
        method: str = &#34;GET&#34;,
        headers: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        headers = headers or {}
        headers[&#34;user-agent&#34;] = self.USER_AGENT

        for session in self.sessions.copy():
            async with session.request(method, url, headers=headers, **kwargs) as r:
                r.raise_for_status()
                data = await r.json()

            if data[&#34;retcode&#34;] == 0:
                return data[&#34;data&#34;]

            try:
                errors.raise_for_retcode(data)
            except errors.TooManyRequests:
                # move the ratelimited session to the end to let the ratelimit wear off
                session = self.sessions.pop(0)
                self.sessions.append(session)

        # if we&#39;re here it means we used up all our sessions so we must handle that
        msg = &#34;All cookies have hit their request limit of 30 accounts per day.&#34;
        raise errors.TooManyRequests({&#34;retcode&#34;: 10101}, msg)

    async def request_daily_reward(self, *args: Any, **kwargs: Any) -&gt; NoReturn:
        &#34;&#34;&#34;Helper overwrite to prevent nasty bugs&#34;&#34;&#34;
        raise RuntimeError(f&#34;{type(self).__name__} does not support daily reward endpoints&#34;)


class ChineseMultiCookieClient(MultiCookieClient, ChineseClient):
    &#34;&#34;&#34;A Genshin Client for chinese endpoints which allows setting multiple cookies&#34;&#34;&#34;


class InternationalClient:
    &#34;&#34;&#34;A client dummy which accepts both overseas and chinese cookies

    Currently in development and probably shouldn&#39;t be used.
    &#34;&#34;&#34;

    os_client: MultiCookieClient
    cn_client: ChineseMultiCookieClient

    def __init__(
        self,
        os_client: MultiCookieClient = None,
        cn_client: ChineseMultiCookieClient = None,
        *,
        debug: bool = False,
    ) -&gt; None:
        warnings.warn(&#34;Initialized an unstable InteractionClient type&#34;)

        self.os_client = os_client or MultiCookieClient(debug=debug)
        self.cn_client = cn_client or ChineseMultiCookieClient(debug=debug)

    async def close(self):
        await asyncio.gather(self.os_client.close(), self.cn_client.close())

    async def set_cookies(
        self,
        cookies: Sequence[Mapping[str, Any]] = None,
        *,
        os: Sequence[Mapping[str, Any]] = None,
        cn: Sequence[Mapping[str, Any]] = None,
    ) -&gt; Tuple[List[Mapping[str, Any]], List[Mapping[str, Any]]]:
        &#34;&#34;&#34;Helper cookie setter that accepts cookie headers

        It is recommended to set os and cn cookies explicitly.

        :param cookies: A list of either os or cn cookies if unknown
        :param os: A list of cookies known to be os
        :param cn: A list of cookies known to be cn
        :returns: A tuple of os cookies and cn cookies
        &#34;&#34;&#34;
        cookies = cookies or []
        os = os or []
        cn = cn or []

        async def is_chinese(cookies: Mapping[str, Any]) -&gt; bool:
            os = GenshinClient(cookies)
            cn = ChineseClient(cookies)

            osd, cnd = await asyncio.gather(
                os.request_hoyolab(f&#34;community/user/wapi/getUserFullInfo?uid={os.hoyolab_uid}&#34;),
                cn.request_hoyolab(f&#34;user/wapi/getUserFullInfo?uid={os.hoyolab_uid}&#34;),
                return_exceptions=True,
            )
            await asyncio.gather(os.close(), cn.close())

            if not isinstance(cnd, Exception):
                return True
            elif not isinstance(osd, Exception):
                return False

            raise Exception(f&#34;Cookie {cookie!r} can&#39;t be found on neither os nor cn servers&#34;)

        self.os_client.set_cookies(os, clear=False)
        self.cn_client.set_cookies(cn, clear=False)

        are_chinese = await asyncio.gather(*(is_chinese(i) for i in cookies))
        for cookie, chinese in zip(cookies, are_chinese):
            if chinese:
                self.cn_client.set_cookies([cookie], clear=False)
            else:
                self.os_client.set_cookies([cookie], clear=False)

        return self.os_client.cookies, self.cn_client.cookies

    def get_activities(self, uid: int, *args: Any, **kwargs: Any):
        client = self.cn_client if is_chinese(uid) else self.os_client
        return client.get_activities(uid, *args, **kwargs)

    def get_characters(self, uid: int, *args: Any, **kwargs: Any):
        client = self.cn_client if is_chinese(uid) else self.os_client
        return client.get_characters(uid, *args, **kwargs)

    def get_full_user(self, uid: int, *args: Any, **kwargs: Any):
        client = self.cn_client if is_chinese(uid) else self.os_client
        return client.get_full_user(uid, *args, **kwargs)

    def get_partial_user(self, uid: int, *args: Any, **kwargs: Any):
        client = self.cn_client if is_chinese(uid) else self.os_client
        return client.get_partial_user(uid, *args, **kwargs)

    def get_spiral_abyss(self, uid: int, *args: Any, **kwargs: Any):
        client = self.cn_client if is_chinese(uid) else self.os_client
        return client.get_spiral_abyss(uid, *args, **kwargs)

    def get_user(self, uid: int, *args: Any, **kwargs: Any):
        client = self.cn_client if is_chinese(uid) else self.os_client
        return client.get_user(uid, *args, **kwargs)

    async def get_record_card(self, hoyolab_uid: int, *args: Any, **kwargs: Any):
        try:
            return await self.os_client.get_record_card(hoyolab_uid, *args, **kwargs)
        except:
            return await self.cn_client.get_record_card(hoyolab_uid, *args, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="genshin.client.ChineseClient"><code class="flex name class">
<span>class <span class="ident">ChineseClient</span></span>
<span>(</span><span>cookies:Mapping[str,str]=None, authkey:str=None, *, lang:str='zh-tw', debug:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cookies</code></strong></dt>
<dd><p>The cookies used for authenticaation</p></dd>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>The authkey used for paginators</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The default language</p></dd>
<dt><strong><code>debug</code></strong></dt>
<dd><p>Whether debug logs should be shown in stdout</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChineseClient(GenshinClient):
    &#34;&#34;&#34;A Genshin Client for chinese endpoints&#34;&#34;&#34;

    DS_SALT = &#34;xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs&#34;
    SIGNIN_SALT = &#34;4a8knnbk5pbjqsrudp3dq484m9axoc5g&#34;
    ACT_ID = &#34;e202009291139501&#34;

    TAKUMI_URL = &#34;https://api-takumi.mihoyo.com/&#34;
    RECORD_URL = &#34;https://api-takumi-record.mihoyo.com/game_record/app/&#34;
    INFO_LEDGER_URL = &#34;https://hk4e-api.mihoyo.com/event/ys_ledger/monthInfo&#34;
    DETAIL_LEDGER_URL = &#34;https://hk4e-api.mihoyo.com/event/ys_ledger/monthDetail&#34;
    REWARD_URL = &#34;https://api-takumi.mihoyo.com/event/bbs_sign_reward/&#34;
    GACHA_INFO_URL = &#34;https://hk4e-api.mihoyo.com/event/gacha_info/api/&#34;
    MAP_URL = &#34;https://api-takumi-static.mihoyo.com/common/map_user/ys_obc/v1/map/&#34;
    STATIC_MAP_URL = &#34;https://api-static.mihoyo.com/common/map_user/ys_obc/v1/map&#34;

    def __init__(
        self,
        cookies: Mapping[str, str] = None,
        authkey: str = None,
        *,
        lang: str = &#34;zh-tw&#34;,
        debug: bool = False,
    ) -&gt; None:
        super().__init__(cookies=cookies, authkey=authkey, lang=lang, debug=debug)

    async def request_hoyolab(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        json: Any = None,
        params: Dict[str, Any] = None,
        cache: Tuple[Any, ...] = None,
        cache_check: Callable[[Any], bool] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        kwargs.pop(&#34;lang&#34;, None)
        params = params or {}

        if cache:
            data = await self._check_cache(cache, cache_check)
            if data:
                return data

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.TAKUMI_URL).join(URL(endpoint))

        # all of this repetition is literally just to change these few lines
        headers = {
            &#34;x-rpc-app_version&#34;: &#34;2.11.1&#34;,
            &#34;x-rpc-client_type&#34;: &#34;5&#34;,
            &#34;ds&#34;: generate_cn_dynamic_secret(self.DS_SALT, json, params),
        }

        data = await self.request(url, method, headers=headers, json=json, params=params, **kwargs)

        if cache:
            await self._update_cache(data, cache, cache_check)

        return data

    async def request_ledger(
        self,
        uid: int = None,
        detail: bool = False,
        *,
        month: int = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the ys ledger endpoint

        Traveler&#39;s diary related data
        &#34;&#34;&#34;
        kwargs.pop(&#34;lang&#34;, None)
        params = params or {}

        url = URL(self.DETAIL_LEDGER_URL if detail else self.INFO_LEDGER_URL)

        params.update(await self._complete_uid(uid, &#34;bind_uid&#34;, &#34;bind_region&#34;))
        params[&#34;month&#34;] = month or datetime.now().month

        return await self.request(url, params=params)

    async def request_daily_reward(
        self,
        endpoint: str,
        uid: int = None,
        *,
        method: str = &#34;GET&#34;,
        params: Dict[str, Any] = None,
        headers: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        kwargs.pop(&#34;lang&#34;, None)
        headers = headers or {}
        params = params or {}

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.REWARD_URL).join(URL(endpoint))

        params.update(await self._complete_uid(uid))

        headers[&#34;x-rpc-app_version&#34;] = &#34;2.10.1&#34;
        headers[&#34;x-rpc-client_type&#34;] = &#34;5&#34;
        headers[&#34;x-rpc-device_id&#34;] = str(uuid.uuid4())
        headers[&#34;ds&#34;] = generate_dynamic_secret(self.SIGNIN_SALT)

        params[&#34;act_id&#34;] = self.ACT_ID

        return await self.request(url, method, params=params, headers=headers, **kwargs)

    async def get_reward_info(self, uid: int = None) -&gt; DailyRewardInfo:
        &#34;&#34;&#34;Get the daily reward info for the current user

        :param uid: Genshin uid of the currently logged-in user
        &#34;&#34;&#34;
        data = await self.request_daily_reward(&#34;info&#34;, uid)
        return DailyRewardInfo(data[&#34;is_sign&#34;], data[&#34;total_sign_day&#34;])

    async def get_monthly_rewards(self) -&gt; List[DailyReward]:
        &#34;&#34;&#34;Get a list of all availible rewards for the current month&#34;&#34;&#34;
        # uid doesn&#39;t matter, this is a static resource
        func = perm_cache(
            (&#34;cn_rewards&#34;, datetime.utcnow().month),
            self.request_daily_reward,
        )
        data = await func(&#34;home&#34;, uid=1)
        return [DailyReward(**i) for i in data[&#34;awards&#34;]]

    def claimed_rewards(self, uid: int = None, *, limit: int = None) -&gt; ChineseDailyRewardPaginator:
        &#34;&#34;&#34;Get all claimed rewards for the current user

        NOTE: Languages are currently broken,
        the language is based off the language used to claim the reward

        :param limit: The maximum amount of rewards to get
        :param lang: The language to use - currently broken
        &#34;&#34;&#34;
        return ChineseDailyRewardPaginator(self, uid, limit=limit)

    @overload
    async def claim_daily_reward(
        self, uid: int = None, *, reward: Literal[True] = ...
    ) -&gt; DailyReward:
        ...

    @overload
    async def claim_daily_reward(self, uid: int = None, *, reward: Literal[False]) -&gt; None:
        ...

    async def claim_daily_reward(
        self, uid: int = None, *, reward: bool = True
    ) -&gt; Optional[DailyReward]:
        &#34;&#34;&#34;Signs into hoyolab and claims the daily reward.

        :param uid: Genshin uid of the currently logged-in user
        :param reward: Whether to also fetch the claimed reward
        &#34;&#34;&#34;
        await self.request_daily_reward(&#34;sign&#34;, uid, method=&#34;POST&#34;)

        if not reward:
            return None

        info, rewards = await asyncio.gather(
            self.get_reward_info(),
            self.get_monthly_rewards(),
        )
        return rewards[info.claimed_rewards - 1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="genshin.client.GenshinClient" href="#genshin.client.GenshinClient">GenshinClient</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="genshin.client.ChineseMultiCookieClient" href="#genshin.client.ChineseMultiCookieClient">ChineseMultiCookieClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="genshin.client.ChineseClient.ACT_ID"><code class="name">var <span class="ident">ACT_ID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.DETAIL_LEDGER_URL"><code class="name">var <span class="ident">DETAIL_LEDGER_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.DS_SALT"><code class="name">var <span class="ident">DS_SALT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.GACHA_INFO_URL"><code class="name">var <span class="ident">GACHA_INFO_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.INFO_LEDGER_URL"><code class="name">var <span class="ident">INFO_LEDGER_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.MAP_URL"><code class="name">var <span class="ident">MAP_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.RECORD_URL"><code class="name">var <span class="ident">RECORD_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.REWARD_URL"><code class="name">var <span class="ident">REWARD_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.SIGNIN_SALT"><code class="name">var <span class="ident">SIGNIN_SALT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.STATIC_MAP_URL"><code class="name">var <span class="ident">STATIC_MAP_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.TAKUMI_URL"><code class="name">var <span class="ident">TAKUMI_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.cache"><code class="name">var <span class="ident">cache</span> :Optional[MutableMapping[Tuple[Any,...],Any]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.fetched_mi18n"><code class="name">var <span class="ident">fetched_mi18n</span> :bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.logger"><code class="name">var <span class="ident">logger</span> :logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.ChineseClient.paginator_cache"><code class="name">var <span class="ident">paginator_cache</span> :Optional[MutableMapping[Tuple[Any,...],Any]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genshin.client.ChineseClient.claim_daily_reward"><code class="name flex">
<span>async def <span class="ident">claim_daily_reward</span></span>(<span>self, uid:int=None, *, reward:bool=True) >Optional[<a title="genshin.models.daily.DailyReward" href="models/daily.html#genshin.models.daily.DailyReward">DailyReward</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>Genshin uid of the currently logged-in user</p></dd>
<dt><strong><code>reward</code></strong></dt>
<dd><p>Whether to also fetch the claimed reward</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def claim_daily_reward(
    self, uid: int = None, *, reward: bool = True
) -&gt; Optional[DailyReward]:
    &#34;&#34;&#34;Signs into hoyolab and claims the daily reward.

    :param uid: Genshin uid of the currently logged-in user
    :param reward: Whether to also fetch the claimed reward
    &#34;&#34;&#34;
    await self.request_daily_reward(&#34;sign&#34;, uid, method=&#34;POST&#34;)

    if not reward:
        return None

    info, rewards = await asyncio.gather(
        self.get_reward_info(),
        self.get_monthly_rewards(),
    )
    return rewards[info.claimed_rewards - 1]</code></pre>
</details>
</dd>
<dt id="genshin.client.ChineseClient.get_monthly_rewards"><code class="name flex">
<span>async def <span class="ident">get_monthly_rewards</span></span>(<span>self) >List[<a title="genshin.models.daily.DailyReward" href="models/daily.html#genshin.models.daily.DailyReward">DailyReward</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of all availible rewards for the current month</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_monthly_rewards(self) -&gt; List[DailyReward]:
    &#34;&#34;&#34;Get a list of all availible rewards for the current month&#34;&#34;&#34;
    # uid doesn&#39;t matter, this is a static resource
    func = perm_cache(
        (&#34;cn_rewards&#34;, datetime.utcnow().month),
        self.request_daily_reward,
    )
    data = await func(&#34;home&#34;, uid=1)
    return [DailyReward(**i) for i in data[&#34;awards&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.ChineseClient.get_reward_info"><code class="name flex">
<span>async def <span class="ident">get_reward_info</span></span>(<span>self, uid:int=None) ><a title="genshin.models.daily.DailyRewardInfo" href="models/daily.html#genshin.models.daily.DailyRewardInfo">DailyRewardInfo</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>Genshin uid of the currently logged-in user</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_reward_info(self, uid: int = None) -&gt; DailyRewardInfo:
    &#34;&#34;&#34;Get the daily reward info for the current user

    :param uid: Genshin uid of the currently logged-in user
    &#34;&#34;&#34;
    data = await self.request_daily_reward(&#34;info&#34;, uid)
    return DailyRewardInfo(data[&#34;is_sign&#34;], data[&#34;total_sign_day&#34;])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="genshin.client.GenshinClient" href="#genshin.client.GenshinClient">GenshinClient</a></b></code>:
<ul class="hlist">
<li><code><a title="genshin.client.GenshinClient.authkey" href="#genshin.client.GenshinClient.authkey">authkey</a></code></li>
<li><code><a title="genshin.client.GenshinClient.calculator" href="#genshin.client.GenshinClient.calculator">calculator</a></code></li>
<li><code><a title="genshin.client.GenshinClient.claimed_rewards" href="#genshin.client.GenshinClient.claimed_rewards">claimed_rewards</a></code></li>
<li><code><a title="genshin.client.GenshinClient.close" href="#genshin.client.GenshinClient.close">close</a></code></li>
<li><code><a title="genshin.client.GenshinClient.cookies" href="#genshin.client.GenshinClient.cookies">cookies</a></code></li>
<li><code><a title="genshin.client.GenshinClient.debug" href="#genshin.client.GenshinClient.debug">debug</a></code></li>
<li><code><a title="genshin.client.GenshinClient.diary_log" href="#genshin.client.GenshinClient.diary_log">diary_log</a></code></li>
<li><code><a title="genshin.client.GenshinClient.fetch_banner_ids" href="#genshin.client.GenshinClient.fetch_banner_ids">fetch_banner_ids</a></code></li>
<li><code><a title="genshin.client.GenshinClient.genshin_accounts" href="#genshin.client.GenshinClient.genshin_accounts">genshin_accounts</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_activities" href="#genshin.client.GenshinClient.get_activities">get_activities</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_banner_details" href="#genshin.client.GenshinClient.get_banner_details">get_banner_details</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_banner_names" href="#genshin.client.GenshinClient.get_banner_names">get_banner_names</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_artifacts" href="#genshin.client.GenshinClient.get_calculator_artifacts">get_calculator_artifacts</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_characters" href="#genshin.client.GenshinClient.get_calculator_characters">get_calculator_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_weapons" href="#genshin.client.GenshinClient.get_calculator_weapons">get_calculator_weapons</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_character_details" href="#genshin.client.GenshinClient.get_character_details">get_character_details</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_character_talents" href="#genshin.client.GenshinClient.get_character_talents">get_character_talents</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_characters" href="#genshin.client.GenshinClient.get_characters">get_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_complete_artifact_set" href="#genshin.client.GenshinClient.get_complete_artifact_set">get_complete_artifact_set</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_diary" href="#genshin.client.GenshinClient.get_diary">get_diary</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_full_user" href="#genshin.client.GenshinClient.get_full_user">get_full_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_gacha_items" href="#genshin.client.GenshinClient.get_gacha_items">get_gacha_items</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_info" href="#genshin.client.GenshinClient.get_map_info">get_map_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_labels" href="#genshin.client.GenshinClient.get_map_labels">get_map_labels</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_locations" href="#genshin.client.GenshinClient.get_map_locations">get_map_locations</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_points" href="#genshin.client.GenshinClient.get_map_points">get_map_points</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_notes" href="#genshin.client.GenshinClient.get_notes">get_notes</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_partial_user" href="#genshin.client.GenshinClient.get_partial_user">get_partial_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_recommended_users" href="#genshin.client.GenshinClient.get_recommended_users">get_recommended_users</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_record_card" href="#genshin.client.GenshinClient.get_record_card">get_record_card</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_spiral_abyss" href="#genshin.client.GenshinClient.get_spiral_abyss">get_spiral_abyss</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_user" href="#genshin.client.GenshinClient.get_user">get_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.hoyolab_uid" href="#genshin.client.GenshinClient.hoyolab_uid">hoyolab_uid</a></code></li>
<li><code><a title="genshin.client.GenshinClient.init" href="#genshin.client.GenshinClient.init">init</a></code></li>
<li><code><a title="genshin.client.GenshinClient.lang" href="#genshin.client.GenshinClient.lang">lang</a></code></li>
<li><code><a title="genshin.client.GenshinClient.login_with_ticket" href="#genshin.client.GenshinClient.login_with_ticket">login_with_ticket</a></code></li>
<li><code><a title="genshin.client.GenshinClient.redeem_code" href="#genshin.client.GenshinClient.redeem_code">redeem_code</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request" href="#genshin.client.GenshinClient.request">request</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_calculator" href="#genshin.client.GenshinClient.request_calculator">request_calculator</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_daily_reward" href="#genshin.client.GenshinClient.request_daily_reward">request_daily_reward</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_gacha_info" href="#genshin.client.GenshinClient.request_gacha_info">request_gacha_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_game_record" href="#genshin.client.GenshinClient.request_game_record">request_game_record</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_hoyolab" href="#genshin.client.GenshinClient.request_hoyolab">request_hoyolab</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_ledger" href="#genshin.client.GenshinClient.request_ledger">request_ledger</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_map" href="#genshin.client.GenshinClient.request_map">request_map</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_transaction" href="#genshin.client.GenshinClient.request_transaction">request_transaction</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_webstatic" href="#genshin.client.GenshinClient.request_webstatic">request_webstatic</a></code></li>
<li><code><a title="genshin.client.GenshinClient.search_users" href="#genshin.client.GenshinClient.search_users">search_users</a></code></li>
<li><code><a title="genshin.client.GenshinClient.session" href="#genshin.client.GenshinClient.session">session</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_authkey" href="#genshin.client.GenshinClient.set_authkey">set_authkey</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_browser_cookies" href="#genshin.client.GenshinClient.set_browser_cookies">set_browser_cookies</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_cache" href="#genshin.client.GenshinClient.set_cache">set_cache</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_cookies" href="#genshin.client.GenshinClient.set_cookies">set_cookies</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_top_characters" href="#genshin.client.GenshinClient.set_top_characters">set_top_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_visibility" href="#genshin.client.GenshinClient.set_visibility">set_visibility</a></code></li>
<li><code><a title="genshin.client.GenshinClient.transaction_log" href="#genshin.client.GenshinClient.transaction_log">transaction_log</a></code></li>
<li><code><a title="genshin.client.GenshinClient.wish_history" href="#genshin.client.GenshinClient.wish_history">wish_history</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="genshin.client.ChineseMultiCookieClient"><code class="flex name class">
<span>class <span class="ident">ChineseMultiCookieClient</span></span>
<span>(</span><span>cookie_list:Iterable[Mapping[str,str]]=None, *, lang:str='en-us', debug:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cookies</code></strong></dt>
<dd><p>The cookies used for authenticaation</p></dd>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>The authkey used for paginators</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The default language</p></dd>
<dt><strong><code>debug</code></strong></dt>
<dd><p>Whether debug logs should be shown in stdout</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChineseMultiCookieClient(MultiCookieClient, ChineseClient):
    &#34;&#34;&#34;A Genshin Client for chinese endpoints which allows setting multiple cookies&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="genshin.client.MultiCookieClient" href="#genshin.client.MultiCookieClient">MultiCookieClient</a></li>
<li><a title="genshin.client.ChineseClient" href="#genshin.client.ChineseClient">ChineseClient</a></li>
<li><a title="genshin.client.GenshinClient" href="#genshin.client.GenshinClient">GenshinClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="genshin.client.ChineseMultiCookieClient.sessions"><code class="name">var <span class="ident">sessions</span> :List[aiohttp.client.ClientSession]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="genshin.client.MultiCookieClient" href="#genshin.client.MultiCookieClient">MultiCookieClient</a></b></code>:
<ul class="hlist">
<li><code><a title="genshin.client.MultiCookieClient.authkey" href="#genshin.client.GenshinClient.authkey">authkey</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.calculator" href="#genshin.client.GenshinClient.calculator">calculator</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.claim_daily_reward" href="#genshin.client.GenshinClient.claim_daily_reward">claim_daily_reward</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.claimed_rewards" href="#genshin.client.GenshinClient.claimed_rewards">claimed_rewards</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.close" href="#genshin.client.MultiCookieClient.close">close</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.cookies" href="#genshin.client.MultiCookieClient.cookies">cookies</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.debug" href="#genshin.client.GenshinClient.debug">debug</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.diary_log" href="#genshin.client.GenshinClient.diary_log">diary_log</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.fetch_banner_ids" href="#genshin.client.GenshinClient.fetch_banner_ids">fetch_banner_ids</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.genshin_accounts" href="#genshin.client.GenshinClient.genshin_accounts">genshin_accounts</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_activities" href="#genshin.client.GenshinClient.get_activities">get_activities</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_banner_details" href="#genshin.client.GenshinClient.get_banner_details">get_banner_details</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_banner_names" href="#genshin.client.GenshinClient.get_banner_names">get_banner_names</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_calculator_artifacts" href="#genshin.client.GenshinClient.get_calculator_artifacts">get_calculator_artifacts</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_calculator_characters" href="#genshin.client.GenshinClient.get_calculator_characters">get_calculator_characters</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_calculator_weapons" href="#genshin.client.GenshinClient.get_calculator_weapons">get_calculator_weapons</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_character_details" href="#genshin.client.GenshinClient.get_character_details">get_character_details</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_character_talents" href="#genshin.client.GenshinClient.get_character_talents">get_character_talents</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_characters" href="#genshin.client.GenshinClient.get_characters">get_characters</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_complete_artifact_set" href="#genshin.client.GenshinClient.get_complete_artifact_set">get_complete_artifact_set</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_diary" href="#genshin.client.GenshinClient.get_diary">get_diary</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_full_user" href="#genshin.client.GenshinClient.get_full_user">get_full_user</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_gacha_items" href="#genshin.client.GenshinClient.get_gacha_items">get_gacha_items</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_map_info" href="#genshin.client.GenshinClient.get_map_info">get_map_info</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_map_labels" href="#genshin.client.GenshinClient.get_map_labels">get_map_labels</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_map_locations" href="#genshin.client.GenshinClient.get_map_locations">get_map_locations</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_map_points" href="#genshin.client.GenshinClient.get_map_points">get_map_points</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_monthly_rewards" href="#genshin.client.GenshinClient.get_monthly_rewards">get_monthly_rewards</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_notes" href="#genshin.client.GenshinClient.get_notes">get_notes</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_partial_user" href="#genshin.client.GenshinClient.get_partial_user">get_partial_user</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_recommended_users" href="#genshin.client.GenshinClient.get_recommended_users">get_recommended_users</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_record_card" href="#genshin.client.GenshinClient.get_record_card">get_record_card</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_reward_info" href="#genshin.client.GenshinClient.get_reward_info">get_reward_info</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_spiral_abyss" href="#genshin.client.GenshinClient.get_spiral_abyss">get_spiral_abyss</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.get_user" href="#genshin.client.GenshinClient.get_user">get_user</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.hoyolab_uid" href="#genshin.client.GenshinClient.hoyolab_uid">hoyolab_uid</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.init" href="#genshin.client.GenshinClient.init">init</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.lang" href="#genshin.client.GenshinClient.lang">lang</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.login_with_ticket" href="#genshin.client.GenshinClient.login_with_ticket">login_with_ticket</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.redeem_code" href="#genshin.client.GenshinClient.redeem_code">redeem_code</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request" href="#genshin.client.GenshinClient.request">request</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_calculator" href="#genshin.client.GenshinClient.request_calculator">request_calculator</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_daily_reward" href="#genshin.client.MultiCookieClient.request_daily_reward">request_daily_reward</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_gacha_info" href="#genshin.client.GenshinClient.request_gacha_info">request_gacha_info</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_game_record" href="#genshin.client.GenshinClient.request_game_record">request_game_record</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_hoyolab" href="#genshin.client.GenshinClient.request_hoyolab">request_hoyolab</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_ledger" href="#genshin.client.GenshinClient.request_ledger">request_ledger</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_map" href="#genshin.client.GenshinClient.request_map">request_map</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_transaction" href="#genshin.client.GenshinClient.request_transaction">request_transaction</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_webstatic" href="#genshin.client.GenshinClient.request_webstatic">request_webstatic</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.search_users" href="#genshin.client.GenshinClient.search_users">search_users</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.session" href="#genshin.client.MultiCookieClient.session">session</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.set_authkey" href="#genshin.client.GenshinClient.set_authkey">set_authkey</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.set_browser_cookies" href="#genshin.client.GenshinClient.set_browser_cookies">set_browser_cookies</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.set_cache" href="#genshin.client.GenshinClient.set_cache">set_cache</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.set_cookies" href="#genshin.client.MultiCookieClient.set_cookies">set_cookies</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.set_top_characters" href="#genshin.client.GenshinClient.set_top_characters">set_top_characters</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.set_visibility" href="#genshin.client.GenshinClient.set_visibility">set_visibility</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.transaction_log" href="#genshin.client.GenshinClient.transaction_log">transaction_log</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.wish_history" href="#genshin.client.GenshinClient.wish_history">wish_history</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="genshin.client.GenshinClient"><code class="flex name class">
<span>class <span class="ident">GenshinClient</span></span>
<span>(</span><span>cookies:Mapping[str,str]=None, authkey:str=None, *, lang:str='en-us', debug:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="vars">Vars:</h2>
<dl>
<dt><strong><code>logger</code></strong></dt>
<dd><p>A logger used for debugging</p></dd>
<dt><strong><code>cache</code></strong></dt>
<dd><p>A cache for http requests</p></dd>
<dt><strong><code>paginator_cache</code></strong></dt>
<dd><p>A high-frequency access cache for paginators</p></dd>
</dl>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cookies</code></strong></dt>
<dd><p>The cookies used for authenticaation</p></dd>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>The authkey used for paginators</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The default language</p></dd>
<dt><strong><code>debug</code></strong></dt>
<dd><p>Whether debug logs should be shown in stdout</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenshinClient:
    &#34;&#34;&#34;A simple http client for genshin endpoints

    :var logger: A logger used for debugging
    :var cache: A cache for http requests
    :var paginator_cache: A high-frequency access cache for paginators
    &#34;&#34;&#34;

    DS_SALT = &#34;6cqshh5dhw73bzxn20oexa9k516chk7s&#34;
    ACT_ID = &#34;e202102251931481&#34;

    WEBSTATIC_URL = &#34;https://webstatic-sea.hoyoverse.com/&#34;
    TAKUMI_URL = &#34;https://api-os-takumi.mihoyo.com/&#34;
    RECORD_URL = &#34;https://bbs-api-os.hoyoverse.com/game_record/&#34;
    INFO_LEDGER_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/ysledgeros/month_info&#34;
    DETAIL_LEDGER_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/ysledgeros/month_detail&#34;
    CALCULATOR_URL = &#34;https://sg-public-api.hoyoverse.com/event/calculateos/&#34;
    REWARD_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/sol/&#34;
    GACHA_INFO_URL = &#34;https://hk4e-api-os.hoyoverse.com/event/gacha_info/api/&#34;
    YSULOG_URL = &#34;https://hk4e-api-os.hoyoverse.com/ysulog/api/&#34;
    MAP_URL = &#34;https://api-os-takumi-static.hoyoverse.com/common/map_user/ys_obc/v1/map/&#34;
    STATIC_MAP_URL = &#34;https://api-os-takumi-static.hoyoverse.com/common/map_user/ys_obc/v1/map&#34;

    USER_AGENT = &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#34;  # noqa: E501

    _session: Optional[aiohttp.ClientSession] = None
    _uid: Optional[int] = None
    logger: logging.Logger = logging.getLogger(__name__)

    cache: Optional[MutableMapping[Tuple[Any, ...], Any]] = None
    paginator_cache: Optional[MutableMapping[Tuple[Any, ...], Any]] = None

    fetched_mi18n: bool = False

    def __init__(
        self,
        cookies: Mapping[str, str] = None,
        authkey: str = None,
        *,
        lang: str = &#34;en-us&#34;,
        debug: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Create a new GenshinClient instance

        :param cookies: The cookies used for authenticaation
        :param authkey: The authkey used for paginators
        :param lang: The default language
        :param debug: Whether debug logs should be shown in stdout
        &#34;&#34;&#34;
        if cookies:
            self.cookies = cookies

        self.authkey = authkey
        self.lang = lang
        self.debug = debug

    def __repr__(self) -&gt; str:
        return f&#34;&lt;{type(self).__name__} lang={self.lang!r} hoyolab_uid={self.hoyolab_uid} debug={self.debug}&gt;&#34;

    # PROPERTIES:

    @property
    def session(self) -&gt; aiohttp.ClientSession:
        &#34;&#34;&#34;The current client session, created when needed&#34;&#34;&#34;
        if self._session is None:
            self._session = aiohttp.ClientSession()

        return self._session

    @property
    def cookies(self) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;The cookie jar belonging to the current session&#34;&#34;&#34;
        return {cookie.key: cookie.value for cookie in self.session.cookie_jar}

    @cookies.setter
    def cookies(self, cookies: Mapping[str, Any]) -&gt; None:
        cks = {str(key): value for key, value in cookies.items()}
        self.session.cookie_jar.clear()
        self.session.cookie_jar.update_cookies(cks)

    @property
    def hoyolab_uid(self) -&gt; Optional[int]:
        &#34;&#34;&#34;The logged-in user&#39;s hoyolab uid&#34;&#34;&#34;
        for cookie in self.session.cookie_jar:
            if cookie.key in (&#34;ltuid&#34;, &#34;account_id&#34;):
                return int(cookie.value)

        return None

    @property
    def uid(self) -&gt; Optional[int]:
        return self._uid

    @uid.setter
    def uid(self, uid: Any) -&gt; None:
        if not str(uid).isdigit() or len(str(uid)) != 9:
            raise TypeError(f&#34;Invalid uid: {uid}&#34;)

        self._uid = int(uid)

    @property
    def lang(self) -&gt; str:
        &#34;&#34;&#34;The default language, defaults to &#34;en-us&#34; &#34;&#34;&#34;
        return self._lang

    @lang.setter
    def lang(self, lang: str) -&gt; None:
        if lang not in LANGS:
            raise ValueError(f&#34;{lang} is not a valid language, must be one of: &#34; + &#34;, &#34;.join(LANGS))

        self._lang = lang

    @property
    def authkey(self) -&gt; Optional[str]:
        &#34;&#34;&#34;The default authkey&#34;&#34;&#34;
        return self._authkey

    @authkey.setter
    def authkey(self, authkey: Optional[str]) -&gt; None:
        if authkey is not None:
            authkey = unquote(authkey)

            try:
                base64.b64decode(authkey, validate=True)
            except Exception as e:
                raise ValueError(&#34;authkey is not a valid base64 encoded string&#34;) from e

        self._authkey = authkey

    @property
    def debug(self) -&gt; bool:
        &#34;&#34;&#34;Whether the debug logs are being shown in stdout&#34;&#34;&#34;
        return logging.getLogger(&#34;genshin&#34;).level == logging.DEBUG

    @debug.setter
    def debug(self, debug: bool) -&gt; None:
        logging.basicConfig()
        level = logging.DEBUG if debug else logging.NOTSET
        logging.getLogger(&#34;genshin&#34;).setLevel(level)

    def set_cookies(
        self, cookies: Union[Mapping[str, Any], str] = None, **kwargs: Any
    ) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;Helper cookie setter that accepts cookie headers

        :returns: The new cookies
        &#34;&#34;&#34;
        if not bool(cookies) ^ bool(kwargs):
            raise TypeError(&#34;Cannot use both positional and keyword arguments at once&#34;)

        cookies = cookies or kwargs
        cookies = {morsel.key: morsel.value for morsel in SimpleCookie(cookies).values()}
        self.cookies = cookies
        return self.cookies

    def set_browser_cookies(self, browser: str = None) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;Extract cookies from your browser and set them as client cookies

        Avalible browsers: chrome, chromium, opera, edge, firefox

        :param browser: The browser to extract the cookies from
        :returns: The extracted cookies
        &#34;&#34;&#34;
        self.cookies = get_browser_cookies(browser)
        return self.cookies

    def set_authkey(self, authkey: str = None) -&gt; None:
        &#34;&#34;&#34;Sets an authkey for wish &amp; transaction logs

        :param authkey: An authkey, a url containing an authkey or a path towards a logfile
        :returns: The new authkey
        &#34;&#34;&#34;
        if authkey is None or os.path.isfile(authkey):
            authkey = get_authkey(authkey)
        else:
            authkey = extract_authkey(authkey) or authkey

        self.authkey = authkey

    def set_cache(
        self,
        maxsize: int,
        strategy: Literal[&#34;FIFO&#34;, &#34;LFU&#34;, &#34;LRU&#34;, &#34;MRU&#34;, &#34;RR&#34;] = &#34;LRU&#34;,
        *,
        ttl: int = None,
        getsizeof: Callable[[Any], float] = None,
    ) -&gt; MutableMapping[Any, Any]:
        &#34;&#34;&#34;Create and set a new cache for http requests

        :param maxsize: The maximum size of the cache
        :param strategy: The cache strategy to use, defaults to Least-Recently-Used
        :param ttl: The time to live of items, only works with LRU caches
        :param getsizeof: Function that gets the size of any objecct, by default everything has size of 1
        :returns: The newly created cache
        &#34;&#34;&#34;
        import cachetools

        if ttl:
            if strategy != &#34;LRU&#34;:
                raise ValueError(&#34;TTL caches must use LRU&#34;)

            self.cache = cachetools.TTLCache(maxsize, ttl, getsizeof=getsizeof)
            return self.cache
        elif strategy == &#34;TTL&#34;:
            raise ValueError(&#34;TTL caches should be set using the ttl kwarg&#34;)

        cls_name = strategy + &#34;Cache&#34;
        if not hasattr(cachetools, cls_name):
            raise ValueError(f&#34;Invalid strategy: {strategy}&#34;)

        self.cache = getattr(cachetools, cls_name)(maxsize, getsizeof=getsizeof)
        return self.cache

    async def _check_cache(
        self,
        key: Tuple[Any, ...],
        check: Callable[[Any], bool] = None,
        *,
        lang: str = None,
    ) -&gt; Optional[Any]:
        &#34;&#34;&#34;Check the cache for any entries&#34;&#34;&#34;
        if self.cache is None:
            return None

        key = key + (lang or self.lang,)

        if key not in self.cache:
            return None

        data = self.cache[key]
        if check is None or check(data):
            return data

        del self.cache[key]

        return None

    async def _update_cache(
        self,
        data: Any,
        key: Tuple[Any, ...],
        check: Callable[[Any], bool] = None,
        *,
        lang: str = None,
    ) -&gt; None:
        &#34;&#34;&#34;Update the cache with a new entry&#34;&#34;&#34;
        if self.cache is None:
            return

        key = key + (lang or self.lang,)

        if check is not None and not check(data):
            return

        self.cache[key] = data

    async def _request_hook(
        self,
        method: str,
        url: Union[str, URL],
        *,
        params: Dict[str, Any] = None,
        json: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;A hook before request, by default performs a debug log&#34;&#34;&#34;
        url = URL(url)
        if params:
            params = {k: v for k, v in params.items() if k != &#34;authkey&#34;}
            url = url.with_query(params)

        string = f&#34;{method} {url}&#34;
        if json:
            string += &#34;\n&#34; + json_.dumps(json, separators=(&#34;,&#34;, &#34;:&#34;))

        self.logger.debug(string)

    # ASYNCIO HANDLERS:

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the underlying aiohttp session&#34;&#34;&#34;
        if not self.session.closed:
            await self.session.close()

    async def __aenter__(self):
        return self

    async def __aexit__(self, *exc_info):
        await self.close()

    # RAW HTTP REQUESTS:

    @handle_ratelimits()
    async def request(
        self,
        url: Union[str, URL],
        method: str = &#34;GET&#34;,
        *,
        headers: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request and return a parsed json response&#34;&#34;&#34;
        asyncio.create_task(self._fetch_mi18n())

        headers = headers or {}
        headers[&#34;User-Agent&#34;] = self.USER_AGENT

        await self._request_hook(method, url, headers=headers, **kwargs)

        async with self.session.request(method, url, headers=headers, **kwargs) as r:
            r.raise_for_status()
            data = await r.json()

        if data[&#34;retcode&#34;] == 0:
            return data[&#34;data&#34;]

        errors.raise_for_retcode(data)

    async def request_webstatic(
        self,
        url: Union[str, URL],
        *,
        headers: Dict[str, Any] = None,
        cache: bool = True,
        **kwargs: Any,
    ) -&gt; Any:
        &#34;&#34;&#34;Request a static json file&#34;&#34;&#34;
        url = URL(self.WEBSTATIC_URL).join(URL(url))

        data = get_from_static_cache(str(url))
        if data is not None:
            return data

        headers = headers or {}
        headers[&#34;user-agent&#34;] = self.USER_AGENT

        async with self.session.get(url, headers=headers, **kwargs) as r:
            r.raise_for_status()
            data = await r.json()

        if cache:
            save_to_static_cache(str(url), data)

        return data

    async def request_hoyolab(
        self,
        endpoint: Union[str, URL],
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        cache: Tuple[Any, ...] = None,
        cache_check: Callable[[Any], bool] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards misc hoyolabs api

        Community related data
        &#34;&#34;&#34;
        if cache:
            data = await self._check_cache(cache, cache_check, lang=lang)
            if data:
                return data

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)
        if lang not in LANGS and lang is not None:
            raise ValueError(f&#34;{lang} is not a valid language, must be one of: &#34; + &#34;, &#34;.join(LANGS))

        url = URL(self.TAKUMI_URL).join(URL(endpoint))

        headers = {
            &#34;x-rpc-app_version&#34;: &#34;1.5.0&#34;,
            &#34;x-rpc-client_type&#34;: &#34;4&#34;,
            &#34;x-rpc-language&#34;: lang or self.lang,
            &#34;ds&#34;: generate_dynamic_secret(self.DS_SALT),
        }

        data = await self.request(url, method, headers=headers, **kwargs)

        if cache:
            await self._update_cache(data, cache, cache_check, lang=lang)

        return data

    async def request_game_record(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        cache: Tuple[Any, ...] = None,
        cache_check: Callable[[Any], bool] = None,
        **kwargs: Any,
    ):
        &#34;&#34;&#34;Make a request towards the game record endpoint

        User stats related data
        &#34;&#34;&#34;
        # this is simply just an alias for shorter request endpoints
        url = URL(self.RECORD_URL).join(URL(endpoint))

        return await self.request_hoyolab(
            url, method=method, cache=cache, cache_check=cache_check, **kwargs
        )

    async def request_ledger(
        self,
        uid: int = None,
        detail: bool = False,
        *,
        month: int = None,
        lang: str = None,
        params: Dict[str, Any] = None,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the ys ledger endpoint

        Traveler&#39;s diary related data
        &#34;&#34;&#34;
        params = params or {}

        url = URL(self.DETAIL_LEDGER_URL if detail else self.INFO_LEDGER_URL)

        params.update(await self._complete_uid(uid))
        params[&#34;month&#34;] = month or datetime.now().month
        params[&#34;lang&#34;] = lang or self.lang

        return await self.request(url, params=params)

    async def request_calculator(
        self,
        endpoint: str,
        *,
        method: str = &#34;POST&#34;,
        lang: str = None,
        params: Dict[str, Any] = None,
        json: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the calculator endpoint

        Calculator database and resource calculation
        &#34;&#34;&#34;
        params = params or {}
        json = json or {}

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.CALCULATOR_URL).join(URL(endpoint))

        if method == &#34;GET&#34;:
            params[&#34;lang&#34;] = lang or self.lang
            json = None
        else:
            json[&#34;lang&#34;] = lang or self.lang

        return await self.request(url, method, params=params, json=json, **kwargs)

    async def request_daily_reward(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the daily reward endpoint

        Daily reward claiming and history
        &#34;&#34;&#34;
        params = params or {}

        if not self.cookies:
            raise RuntimeError(&#34;No cookies provided&#34;)

        url = URL(self.REWARD_URL).join(URL(endpoint))

        params[&#34;lang&#34;] = lang or self.lang
        params[&#34;act_id&#34;] = self.ACT_ID

        return await self.request(url, method, params=params, **kwargs)

    async def request_gacha_info(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        authkey: Optional[str] = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the game info endpoint

        Wish history related data
        &#34;&#34;&#34;
        params = params or {}
        authkey = authkey or self.authkey

        if authkey is None:
            raise RuntimeError(&#34;No authkey provided&#34;)

        base_url = URL(self.GACHA_INFO_URL)
        url = base_url.join(URL(endpoint))

        params[&#34;authkey_ver&#34;] = 1
        params[&#34;authkey&#34;] = unquote(authkey)
        params[&#34;lang&#34;] = create_short_lang_code(lang or self.lang)

        return await self.request(url, method, params=params, **kwargs)

    async def request_transaction(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        authkey: Optional[str] = None,
        params: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the transaction log endpoint

        Transaction related data
        &#34;&#34;&#34;
        params = params or {}
        authkey = authkey or self.authkey

        if authkey is None:
            raise RuntimeError(&#34;No authkey provided&#34;)

        base_url = URL(self.YSULOG_URL)
        url = base_url.join(URL(endpoint))

        params[&#34;authkey_ver&#34;] = 1
        params[&#34;sign_type&#34;] = 2
        params[&#34;authkey&#34;] = unquote(authkey)
        params[&#34;lang&#34;] = create_short_lang_code(lang or self.lang)

        return await self.request(url, method, params=params, **kwargs)

    async def request_map(
        self,
        endpoint: str,
        *,
        method: str = &#34;GET&#34;,
        lang: str = None,
        map_id: int = 2,
        static: bool = False,
        params: Dict[str, Any] = None,
        **kwargs,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Make a request towards the map endpoint

        Interactive map related data
        &#34;&#34;&#34;
        params = params or {}

        base_url = self.STATIC_MAP_URL if static else self.MAP_URL
        url = URL(base_url).join(URL(endpoint))

        params[&#34;map_id&#34;] = map_id
        params[&#34;app_sn&#34;] = &#34;ys_obc&#34;
        params[&#34;lang&#34;] = lang or self.lang

        return await self.request(url, method, params=params, **kwargs)

    async def login_with_ticket(self, login_ticket: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Complete cookies using a login ticket&#34;&#34;&#34;
        url = &#34;https://webapi-os.account.hoyoverse.com/Api/cookie_accountinfo_by_loginticket&#34;
        async with self.session.get(url, params=dict(login_ticket=login_ticket)) as r:
            r.raise_for_status()

    # HOYOLAB:

    async def genshin_accounts(self, *, lang: str = None) -&gt; List[GenshinAccount]:
        &#34;&#34;&#34;Get the genshin accounts of the currently logged-in user

        :params lang: The language to use
        &#34;&#34;&#34;
        # TODO: Account for honkai accounts

        # fmt: off
        data = await self.request_hoyolab(
            &#34;binding/api/getUserGameRolesByCookie&#34;,
            lang=lang,
            cache=(&#34;accounts&#34;, self.hoyolab_uid)
        )
        # fmt: on
        return [GenshinAccount(**i) for i in data[&#34;list&#34;]]

    async def search_users(self, keyword: str, *, lang: str = None) -&gt; List[SearchUser]:
        &#34;&#34;&#34;Search hoyolab users

        :param keyword: The keyword to search with
        :params lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_hoyolab(
            &#34;community/search/wapi/search/user&#34;,
            lang=lang,
            params=dict(keyword=keyword, page_size=20),
            cache=(&#34;search&#34;, keyword),
        )
        return [SearchUser(**i[&#34;user&#34;]) for i in data[&#34;list&#34;]]

    async def set_visibility(self, public: bool) -&gt; None:
        &#34;&#34;&#34;Sets your data to public or private.

        :param public: Whether the data should now be public
        &#34;&#34;&#34;
        await self.request_game_record(
            &#34;genshin/wapi/publishGameRecord&#34;,
            method=&#34;POST&#34;,
            json=dict(is_public=public, game_id=2),
        )

    async def get_recommended_users(self, *, limit: int = 200) -&gt; List[SearchUser]:
        &#34;&#34;&#34;Get a list of recommended active users

        :param limit: The maximum amount of users to return
        &#34;&#34;&#34;
        data = await self.request_hoyolab(
            &#34;community/user/wapi/recommendActive&#34;,
            params=dict(page_size=limit),
        )
        return [SearchUser(**i[&#34;user&#34;]) for i in data[&#34;list&#34;]]

    async def redeem_code(self, code: str, uid: int = None, *, lang: str = None) -&gt; None:
        &#34;&#34;&#34;Redeems a gift code for the current user

        :param code: The code to redeem
        :param uid: The specific uid to redeem for
        :param lang: The language to use
        &#34;&#34;&#34;
        # do note that this endpoint is very quirky, can&#39;t really make this pretty
        if uid is not None:
            server = recognize_server(uid)
            lang = create_short_lang_code(lang or self.lang)
            await self.request(
                &#34;https://hk4e-api-os.hoyoverse.com/common/apicdkey/api/webExchangeCdkey&#34;,
                params=dict(
                    uid=uid,
                    region=server,
                    cdkey=code,
                    game_biz=&#34;hk4e_global&#34;,
                    lang=lang,
                ),
            )
            return

        accounts = [a for a in await self.genshin_accounts() if a.level &gt;= 10]

        for i, account in enumerate(accounts):
            # there&#39;s a ratelimit of 1 request every 5 seconds
            if i:
                await asyncio.sleep(5)

            await self.redeem_code(code, account.uid, lang=lang)

    # GAME RECORD:

    async def _fetch_raw_user(self, uid: int, lang: str = None) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Low-level http method for fetching the game record index&#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/index&#34;,
            lang=lang,
            params=dict(server=server, role_id=uid),
            cache=(&#34;user&#34;, uid),
        )
        return data

    async def _fetch_raw_characters(self, uid: int, *, lang: str = None) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Low-level http method for fetching the game record characters

        Caching with characters is optimized
        &#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/character&#34;,
            method=&#34;POST&#34;,
            lang=lang,
            json=dict(role_id=uid, server=server),
            cache=(&#34;characters&#34;, uid),
        )

        return data[&#34;avatars&#34;]

    async def get_record_card(self, hoyolab_uid: int = None, *, lang: str = None) -&gt; RecordCard:
        &#34;&#34;&#34;Get a user&#39;s record card

        :param hoyolab_uid: A hoyolab uid
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_game_record(
            &#34;card/wapi/getGameRecordCard&#34;,
            lang=lang,
            params=dict(uid=hoyolab_uid or self.hoyolab_uid),
            cache=(&#34;record&#34;, hoyolab_uid),
            cache_check=lambda data: len(data[&#34;list&#34;]) &gt; 0,
        )
        cards = data[&#34;list&#34;]
        if not cards:
            raise errors.DataNotPublic({&#34;retcode&#34;: 10102})

        return RecordCard(**cards[0])

    async def get_user(self, uid: int, *, lang: str = None) -&gt; UserStats:
        &#34;&#34;&#34;Get a user&#39;s stats and characters

        :param uid: A Genshin uid
        :param character_ids: The ids of characters you want to fetch
        :param all_characters: Whether to get every single character a user has. Discouraged.
        :param lang: The language to use
        &#34;&#34;&#34;
        data, characters = await asyncio.gather(
            self._fetch_raw_user(uid, lang=lang),
            self._fetch_raw_characters(uid, lang=lang),
        )
        data[&#34;avatars&#34;] = characters

        return UserStats(**data)

    async def get_partial_user(self, uid: int, *, lang: str = None) -&gt; PartialUserStats:
        &#34;&#34;&#34;Helper function to get a user without any equipment

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._fetch_raw_user(uid, lang=lang)
        return PartialUserStats(**data)

    async def get_characters(self, uid: int, *, lang: str = None) -&gt; List[Character]:
        &#34;&#34;&#34;Helper function to fetch characters from just their ids

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._fetch_raw_characters(uid, lang=lang)
        return [Character(**i) for i in data]

    async def get_spiral_abyss(
        self, uid: int, *, previous: bool = False, lang: str = None
    ) -&gt; SpiralAbyss:
        &#34;&#34;&#34;Get spiral abyss runs

        :param uid: A Genshin uid
        :param previous: Whether to get the record of the previous spiral abyss
        :param lang: The language to use
        &#34;&#34;&#34;
        server = recognize_server(uid)
        schedule_type = 2 if previous else 1
        data = await self.request_game_record(
            &#34;genshin/api/spiralAbyss&#34;,
            lang=lang,
            params=dict(role_id=uid, server=server, schedule_type=schedule_type),
            cache=(&#34;abyss&#34;, uid, schedule_type),
        )
        return SpiralAbyss(**data)

    async def get_notes(self, uid: int, *, lang: str = None) -&gt; Notes:
        &#34;&#34;&#34;Get the real-time notes.

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/dailyNote&#34;,
            lang=lang,
            params=dict(server=server, role_id=uid),
        )
        return Notes(**data)

    async def get_activities(self, uid: int, *, lang: str = None) -&gt; Activities:
        &#34;&#34;&#34;Get activities

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        server = recognize_server(uid)
        data = await self.request_game_record(
            &#34;genshin/api/activities&#34;,
            lang=lang,
            params=dict(server=server, role_id=uid),
            cache=(&#34;activities&#34;, uid),
        )
        return Activities(**data)

    async def get_full_user(self, uid: int, *, lang: str = None) -&gt; FullUserStats:
        &#34;&#34;&#34;Get a user with all their possible data

        :param uid: A Genshin uid
        :param lang: The language to use
        &#34;&#34;&#34;
        user, abyss1, abyss2, activities = await asyncio.gather(
            self.get_user(uid, lang=lang),
            self.get_spiral_abyss(uid, lang=lang, previous=False),
            self.get_spiral_abyss(uid, lang=lang, previous=True),
            self.get_activities(uid, lang=lang),
        )
        abyss = {&#34;current&#34;: abyss1, &#34;previous&#34;: abyss2}
        return FullUserStats(**user.dict(), abyss=abyss, activities=activities)

    async def set_top_characters(self, character_ids: List[int], *, uid: int = None) -&gt; None:
        &#34;&#34;&#34;Set the top 8 visible characters for the current user

        :param character_ids: IDs of characters to be shown
        :param uid: Genshin uid of the currently logged-in user
        &#34;&#34;&#34;
        json = dict(avatar_ids=character_ids)
        json.update(await self._complete_uid(uid, uid_key=&#34;role_id&#34;, server_key=&#34;server&#34;))
        await self.request_game_record(
            &#34;genshin/api/character/top&#34;,
            method=&#34;POST&#34;,
            json=json,
        )

    # LEDGER:

    async def get_diary(self, uid: int = None, *, month: int = None, lang: str = None) -&gt; Diary:
        &#34;&#34;&#34;Get a traveler&#39;s diary with earning details for the month

        :param uid: Genshin uid of the currently logged-in user
        :param month: The month in the year to see the history for
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_ledger(uid, month=month, lang=lang)
        return Diary(**data)

    def diary_log(
        self,
        uid: int = None,
        *,
        mora: bool = False,
        month: int = None,
        limit: int = None,
        lang: str = None,
    ) -&gt; DiaryPaginator:
        &#34;&#34;&#34;Create a new daily reward pagintor

        :param client: A client for making http requests
        :param uid: Genshin uid of the currently logged-in user
        :param mora: Whether the type of currency should be mora instead of primogems
        :param month: The month in the year to see the history for
        :param limit: The maximum amount of actions to get
        :param lang: The language to use
        &#34;&#34;&#34;
        type = 2 if mora else 1
        return DiaryPaginator(self, uid, type, month, limit, lang)

    # CALCULATOR

    def calculator(self, *, lang: str = None) -&gt; CalculatorBuilder:
        &#34;&#34;&#34;Calculate the resources needed to level up various equipment.

        :param lang: The language to use
        &#34;&#34;&#34;
        return CalculatorBuilder(self, lang=lang)

    async def _execute_calculator(self, builder: CalculatorBuilder) -&gt; CalculatorResult:
        &#34;&#34;&#34;Create a request to calculate the results of a builder&#34;&#34;&#34;
        json = await builder.build()
        data = await self.request_calculator(&#34;compute&#34;, lang=builder.lang, json=json)
        return CalculatorResult(**data)

    async def _get_calculator_items(
        self,
        slug: str,
        filters: Dict[str, Any],
        query: str = None,
        *,
        is_all: bool = False,
        sync: Union[int, bool] = False,
        lang: str = None,
    ) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Get all items of a specific slug from a calculator&#34;&#34;&#34;
        if query and any(isinstance(v, list) and v for v in filters.values()):
            raise TypeError(&#34;Cannot specify a query and filter at the same time&#34;)

        endpoint = f&#34;sync/{slug}/list&#34; if sync else f&#34;{slug}/list&#34;
        json: Dict[str, Any] = dict(page=1, size=69420, is_all=is_all, **filters)
        if query:
            json.update(keywords=query)
        if sync:
            json.update(await self._complete_uid(sync if sync &gt; 1 else None))

        data = await self.request_calculator(
            endpoint,
            lang=lang,
            json=json,
        )
        return data[&#34;list&#34;]

    async def get_calculator_characters(
        self,
        *,
        query: str = None,
        elements: Sequence[int] = None,
        weapon_types: Sequence[int] = None,
        include_traveler: bool = False,
        sync: Union[int, bool] = False,
        lang: str = None,
    ) -&gt; List[CalculatorCharacter]:
        &#34;&#34;&#34;Get all characters provided by the Enhancement Progression Calculator

        :param query: A query to use when searching; incompatible with other filters
        :param elements: The elements of returned characters - refer to `.models.CALCULATOR_ELEMENTS`
        :param weapon_types: The weapon types of returned characters - refer to `.models.CALCULATOR_WEAPON_TYPES`
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._get_calculator_items(
            &#34;avatar&#34;,
            lang=lang,
            is_all=include_traveler,
            sync=sync,
            query=query,
            filters=dict(
                element_attr_ids=elements or [],
                weapon_cat_ids=weapon_types or [],
            ),
        )
        return [CalculatorCharacter(**i) for i in data]

    async def get_calculator_weapons(
        self,
        *,
        query: str = None,
        types: Sequence[int] = None,
        rarities: Sequence[int] = None,
        lang: str = None,
    ) -&gt; List[CalculatorWeapon]:
        &#34;&#34;&#34;Get all weapons provided by the Enhancement Progression Calculator

        :param query: A query to use when searching; incompatible with other filters
        :param types: The types of returned weapons - refer to `.models.CALCULATOR_WEAPON_TYPES`
        :param rarities: The rarities of returned weapons
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._get_calculator_items(
            &#34;weapon&#34;,
            lang=lang,
            query=query,
            filters=dict(
                weapon_cat_ids=types or [],
                weapon_levels=rarities or [],
            ),
        )
        return [CalculatorWeapon(**i) for i in data]

    async def get_calculator_artifacts(
        self,
        *,
        query: str = None,
        pos: int = 1,
        rarities: Sequence[int] = None,
        lang: str = None,
    ) -&gt; List[CalculatorArtifact]:
        &#34;&#34;&#34;Get all artifacts provided by the Enhancement Progression Calculator

        :param query: A query to use when searching; incompatible with other filters
        :param pos: The slot position of the returned weapon
        :param rarities: The rarities of returned artifacts
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self._get_calculator_items(
            &#34;reliquary&#34;,
            lang=lang,
            query=query,
            filters=dict(
                reliquary_cat_id=pos,
                reliquary_levels=rarities or [],
            ),
        )
        return [CalculatorArtifact(**i) for i in data]

    async def get_character_details(
        self,
        character_id: int,
        *,
        uid: int = None,
        lang: str = None,
    ) -&gt; CalculatorCharacterDetails:
        &#34;&#34;&#34;Get the weapon, artifacts and talents of a character

        Not related to the Battle Chronicle. This data is always private.

        :param lang: The language to use
        &#34;&#34;&#34;
        params = dict(avatar_id=character_id)
        params.update(await self._complete_uid(uid))

        data = await self.request_calculator(
            &#34;sync/avatar/detail&#34;,
            method=&#34;GET&#34;,
            lang=lang,
            params=params,
        )
        return CalculatorCharacterDetails(**data)

    async def get_character_talents(
        self,
        character_id: int,
        *,
        lang: str = None,
    ) -&gt; List[CalculatorTalent]:
        &#34;&#34;&#34;Get the talents of a character

        This only gets the talent names, not their levels.
        Use `get_character_details` for precise information.

        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_calculator(
            &#34;avatar/skill_list&#34;,
            method=&#34;GET&#34;,
            lang=lang,
            params=dict(avatar_id=character_id),
        )
        return [CalculatorTalent(**i) for i in data[&#34;list&#34;]]

    async def get_complete_artifact_set(
        self,
        artifact_id: int,
        *,
        lang: str = None,
    ) -&gt; List[CalculatorArtifact]:
        &#34;&#34;&#34;Get all other artifacts that share a set with any given artifact

        Doesn&#39;t return the artifact passed into this function.

        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_calculator(
            &#34;reliquary/set&#34;,
            method=&#34;GET&#34;,
            lang=lang,
            params=dict(reliquary_id=artifact_id),
        )
        return [CalculatorArtifact(**i) for i in data[&#34;reliquary_list&#34;]]

    # DAILY REWARDS:

    async def get_reward_info(self, *, lang: str = None) -&gt; DailyRewardInfo:
        &#34;&#34;&#34;Get the daily reward info for the current user

        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_daily_reward(&#34;info&#34;, lang=lang)
        return DailyRewardInfo(data[&#34;is_sign&#34;], data[&#34;total_sign_day&#34;])

    async def get_monthly_rewards(self, *, lang: str = None) -&gt; List[DailyReward]:
        &#34;&#34;&#34;Get a list of all availible rewards for the current month

        :param lang: The language to use
        &#34;&#34;&#34;
        func = perm_cache(
            (&#34;rewards&#34;, datetime.utcnow().month, lang or self.lang),
            self.request_daily_reward,
        )
        data = await func(&#34;home&#34;, lang=lang)
        return [DailyReward(**i) for i in data[&#34;awards&#34;]]

    def claimed_rewards(self, *, limit: int = None, lang: str = None) -&gt; DailyRewardPaginator:
        &#34;&#34;&#34;Get all claimed rewards for the current user

        NOTE: Languages are currently broken,
        the language is based off the language used to claim the reward

        :param limit: The maximum amount of rewards to get
        :param lang: The language to use - currently broken
        &#34;&#34;&#34;
        return DailyRewardPaginator(self, limit=limit, lang=lang)

    @overload
    async def claim_daily_reward(
        self, *, lang: str = None, reward: Literal[True] = ...
    ) -&gt; DailyReward:
        ...

    @overload
    async def claim_daily_reward(self, *, lang: str = None, reward: Literal[False]) -&gt; None:
        ...

    async def claim_daily_reward(
        self, *, lang: str = None, reward: bool = True
    ) -&gt; Optional[DailyReward]:
        &#34;&#34;&#34;Signs into hoyolab and claims the daily reward.

        :param lang: The language to use
        :param reward: Whether to also fetch the claimed reward
        &#34;&#34;&#34;
        await self.request_daily_reward(&#34;sign&#34;, method=&#34;POST&#34;, lang=lang)

        if not reward:
            return None

        info, rewards = await asyncio.gather(
            self.get_reward_info(lang=lang),
            self.get_monthly_rewards(lang=lang),
        )
        return rewards[info.claimed_rewards - 1]

    # WISH HISTORY:

    @overload
    def wish_history(
        self,
        banner_type: Optional[List[BannerType]] = ...,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; MergedWishHistory:
        ...

    @overload
    def wish_history(
        self,
        banner_type: BannerType,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; WishHistory:
        ...

    def wish_history(
        self,
        banner_type: Union[BannerType, List[BannerType]] = None,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Union[WishHistory, MergedWishHistory]:
        &#34;&#34;&#34;Get the wish history of a user

        :param banner_type: The banner(s) from which to get the wishes
        :param limit: The maximum amount of wishes to get
        :param lang: The language to use
        :param authkey: The authkey to use when requesting data
        :param end_id: The ending id to start getting data from
        &#34;&#34;&#34;
        cls = WishHistory if isinstance(banner_type, int) else MergedWishHistory
        return cls(
            self,
            banner_type,  # type: ignore
            lang=lang,
            authkey=authkey,
            limit=limit,
            end_id=end_id,
        )

    async def get_banner_names(
        self, *, lang: str = None, authkey: str = None
    ) -&gt; Dict[BannerType, str]:
        &#34;&#34;&#34;Get a list of banner names

        :param lang: The language to use
        :param authkey: The authkey to use when requesting data
        &#34;&#34;&#34;
        func = perm_cache((&#34;banners&#34;, lang or self.lang), self.request_gacha_info)
        data = await func(
            &#34;getConfigList&#34;,
            lang=lang,
            authkey=authkey,
        )
        return {int(i[&#34;key&#34;]): i[&#34;name&#34;] for i in data[&#34;gacha_type_list&#34;]}  # type: ignore

    async def _get_banner_details(self, banner_id: str, *, lang: str = None) -&gt; BannerDetails:
        &#34;&#34;&#34;Get details of a specific banner using its id

        :param banner_id: A banner id
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_webstatic(
            f&#34;/hk4e/gacha_info/os_asia/{banner_id}/{lang or self.lang}.json&#34;
        )
        return BannerDetails(**data, banner_id=banner_id)

    async def get_banner_details(
        self, banner_ids: List[str] = None, *, lang: str = None
    ) -&gt; List[BannerDetails]:
        &#34;&#34;&#34;Get all banner details at once in a batch

        :param banner_ids: A list of banner ids, implicitly fetched when not provided
        :param lang: The language to use
        &#34;&#34;&#34;
        try:
            banner_ids = banner_ids or get_banner_ids()
        except FileNotFoundError:
            banner_ids = []

        if len(banner_ids) &lt; 3:
            banner_ids = await self.fetch_banner_ids()

        data = await asyncio.gather(*(self._get_banner_details(i, lang=lang) for i in banner_ids))
        return list(data)

    async def get_gacha_items(
        self, *, server: str = &#34;os_asia&#34;, lang: str = None
    ) -&gt; List[GachaItem]:
        &#34;&#34;&#34;Get the list of characters and weapons that can be gotten from the gacha.

        :param server: The server to request the items from
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_webstatic(
            f&#34;/hk4e/gacha_info/{server}/items/{lang or self.lang}.json&#34;, cache=False
        )
        return [GachaItem(**i) for i in data]

    # TRANSACTIONS:

    async def _get_transaction_reasons(self, lang: str) -&gt; Dict[str, str]:
        &#34;&#34;&#34;Get a mapping of transaction reasons

        :param lang: The language to use
        &#34;&#34;&#34;
        base = &#34;https://mi18n-os.hoyoverse.com/webstatic/admin/mi18n/hk4e_global/&#34;
        data = await self.request_webstatic(base + f&#34;m02251421001311/m02251421001311-{lang}.json&#34;)

        return {
            k.split(&#34;_&#34;)[-1]: v
            for k, v in data.items()
            if k.startswith(&#34;selfinquiry_general_reason_&#34;)
        }

    @overload
    def transaction_log(
        self,
        kind: Optional[List[TransactionKind]] = ...,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; MergedTransactions:
        ...

    @overload
    def transaction_log(
        self,
        kind: Literal[&#34;primogem&#34;, &#34;crystal&#34;, &#34;resin&#34;],
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Transactions[Transaction]:
        ...

    @overload
    def transaction_log(
        self,
        kind: Literal[&#34;artifact&#34;, &#34;weapon&#34;],
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Transactions[ItemTransaction]:
        ...

    def transaction_log(
        self,
        kind: Union[TransactionKind, List[TransactionKind]] = None,
        *,
        limit: int = None,
        lang: str = None,
        authkey: str = None,
        end_id: int = 0,
    ) -&gt; Union[Transactions[Any], MergedTransactions]:
        &#34;&#34;&#34;Get the transaction log of a user

        :param kind: The kind(s) of transactions to get
        :param limit: The maximum amount of wishes to get
        :param lang: The language to use
        :param authkey: The authkey to use when requesting data
        :param end_id: The ending id to start getting data from
        &#34;&#34;&#34;
        cls = Transactions if isinstance(kind, str) else MergedTransactions
        return cls(
            self,
            kind,  # type: ignore
            lang=lang,
            authkey=authkey,
            limit=limit,
            end_id=end_id,
        )

    # INTERACTIVE MAP:

    async def _get_map_pin_icons(self, map_id: int = 2, *, lang: str = None) -&gt; Dict[int, str]:
        &#34;&#34;&#34;Get the icons of pins&#34;&#34;&#34;
        data = await self.request_map(&#34;spot_kind/get_icon_list&#34;, lang=lang, map_id=map_id)
        return {i[&#34;id&#34;]: i[&#34;url&#34;] for i in data[&#34;icons&#34;]}

    async def get_map_info(self, map_id: int = 2, *, lang: str = None) -&gt; MapInfo:
        &#34;&#34;&#34;Get info about an interactive map&#34;&#34;&#34;
        data = await self.request_map(
            &#34;map/info&#34;,
            lang=lang,
            map_id=map_id,
            static=True,
        )
        return MapInfo(**data[&#34;info&#34;])

    async def get_map_labels(self, map_id: int = 2, *, lang: str = None) -&gt; List[MapNode]:
        &#34;&#34;&#34;Get the map tree of all categories &amp; lables of map points

        :param map_id: The id of the map
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_map(&#34;map/label/tree&#34;, lang=lang, map_id=map_id, static=True)
        return [MapNode(**i) for i in data[&#34;tree&#34;]]

    async def get_map_points(
        self, map_id: int = 2, *, lang: str = None
    ) -&gt; Tuple[List[MapNode], List[MapPoint]]:
        &#34;&#34;&#34;Get a tuple of all map lables and map points

        :param map_id: The id of the map
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_map(&#34;map/point/list&#34;, lang=lang, map_id=map_id, static=True)

        labels = [MapNode(**i) for i in data[&#34;label_list&#34;]]
        points = [MapPoint(**i) for i in data[&#34;point_list&#34;]]

        return labels, points

    async def get_map_locations(self, map_id: int = 2, *, lang: str = None) -&gt; List[MapLocation]:
        &#34;&#34;&#34;Get a list of all locations on a map

        :param map_id: The id of the map
        :param lang: The language to use
        &#34;&#34;&#34;
        data = await self.request_map(&#34;map/map_anchor/list&#34;, lang=lang, map_id=map_id, static=True)

        return [MapLocation(**i) for i in data[&#34;list&#34;]]

    # MISC:

    async def _complete_uid(
        self,
        uid: Optional[int] = None,
        uid_key: str = &#34;uid&#34;,
        server_key: str = &#34;region&#34;,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Create a new dict with a uid and a server

        These are fetched from the currently authenticated user
        &#34;&#34;&#34;
        params: Dict[str, Any] = {}

        uid = uid or self._uid

        if uid is None:
            accounts = await self.genshin_accounts()
            # filter test servers
            accounts = [
                account for account in accounts if &#34;os&#34; in account.server or &#34;cn&#34; in account.server
            ]

            # TODO: Raise properly
            if not accounts:
                errors.raise_for_retcode({&#34;retcode&#34;: -1073})

            account = max(accounts, key=lambda a: a.level)
            uid = account.uid

            self._uid = uid

        params[uid_key] = uid
        params[server_key] = recognize_server(uid)

        return params

    async def _fetch_mi18n(self) -&gt; Dict[str, Dict[str, str]]:
        if self.fetched_mi18n:
            return GenshinModel._mi18n

        self.fetched_mi18n = True

        async def single(url: str, key: str, lang: str = None):
            if lang is None:
                coros = (single(url, key, l) for l in LANGS)
                return await asyncio.gather(*coros)

            data = await self.request_webstatic(url.format(lang=lang))
            for k, v in data.items():
                GenshinModel._mi18n.setdefault(key + &#34;/&#34; + k, {})[lang] = v

        coros = (single(url, key) for key, url in GenshinModel._mi18n_urls.items())
        await asyncio.gather(*coros)

        return GenshinModel._mi18n

    async def init(self, lang: str = None):
        &#34;&#34;&#34;Request all static &amp; permanent endpoints to not require them later

        :param lang: The language to use
        &#34;&#34;&#34;
        lang = lang or self.lang

        await asyncio.gather(
            self.get_banner_names(lang=lang),
            self.get_banner_details(lang=lang),
            self.get_monthly_rewards(),
            self._get_transaction_reasons(lang=lang),
            self._fetch_mi18n(),
        )

    async def fetch_banner_ids(self) -&gt; List[str]:
        &#34;&#34;&#34;Fetch banner ids from a user-mantained repo&#34;&#34;&#34;
        url = &#34;https://raw.githubusercontent.com/thesadru/genshindata/master/banner_ids.txt&#34;
        async with self.session.get(url) as r:
            data = await r.text()
        return data.splitlines()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="genshin.client.ChineseClient" href="#genshin.client.ChineseClient">ChineseClient</a></li>
<li><a title="genshin.client.MultiCookieClient" href="#genshin.client.MultiCookieClient">MultiCookieClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="genshin.client.GenshinClient.ACT_ID"><code class="name">var <span class="ident">ACT_ID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.CALCULATOR_URL"><code class="name">var <span class="ident">CALCULATOR_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.DETAIL_LEDGER_URL"><code class="name">var <span class="ident">DETAIL_LEDGER_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.DS_SALT"><code class="name">var <span class="ident">DS_SALT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.GACHA_INFO_URL"><code class="name">var <span class="ident">GACHA_INFO_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.INFO_LEDGER_URL"><code class="name">var <span class="ident">INFO_LEDGER_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.MAP_URL"><code class="name">var <span class="ident">MAP_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.RECORD_URL"><code class="name">var <span class="ident">RECORD_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.REWARD_URL"><code class="name">var <span class="ident">REWARD_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.STATIC_MAP_URL"><code class="name">var <span class="ident">STATIC_MAP_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.TAKUMI_URL"><code class="name">var <span class="ident">TAKUMI_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.USER_AGENT"><code class="name">var <span class="ident">USER_AGENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.WEBSTATIC_URL"><code class="name">var <span class="ident">WEBSTATIC_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.YSULOG_URL"><code class="name">var <span class="ident">YSULOG_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.cache"><code class="name">var <span class="ident">cache</span> :Optional[MutableMapping[Tuple[Any,...],Any]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.fetched_mi18n"><code class="name">var <span class="ident">fetched_mi18n</span> :bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.logger"><code class="name">var <span class="ident">logger</span> :logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genshin.client.GenshinClient.paginator_cache"><code class="name">var <span class="ident">paginator_cache</span> :Optional[MutableMapping[Tuple[Any,...],Any]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="genshin.client.GenshinClient.authkey"><code class="name">var <span class="ident">authkey</span> :Optional[str]</code></dt>
<dd>
<div class="desc"><p>The default authkey</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def authkey(self) -&gt; Optional[str]:
    &#34;&#34;&#34;The default authkey&#34;&#34;&#34;
    return self._authkey</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.cookies"><code class="name">var <span class="ident">cookies</span> :Mapping[str,str]</code></dt>
<dd>
<div class="desc"><p>The cookie jar belonging to the current session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cookies(self) -&gt; Mapping[str, str]:
    &#34;&#34;&#34;The cookie jar belonging to the current session&#34;&#34;&#34;
    return {cookie.key: cookie.value for cookie in self.session.cookie_jar}</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.debug"><code class="name">var <span class="ident">debug</span> :bool</code></dt>
<dd>
<div class="desc"><p>Whether the debug logs are being shown in stdout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def debug(self) -&gt; bool:
    &#34;&#34;&#34;Whether the debug logs are being shown in stdout&#34;&#34;&#34;
    return logging.getLogger(&#34;genshin&#34;).level == logging.DEBUG</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.hoyolab_uid"><code class="name">var <span class="ident">hoyolab_uid</span> :Optional[int]</code></dt>
<dd>
<div class="desc"><p>The logged-in user's hoyolab uid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hoyolab_uid(self) -&gt; Optional[int]:
    &#34;&#34;&#34;The logged-in user&#39;s hoyolab uid&#34;&#34;&#34;
    for cookie in self.session.cookie_jar:
        if cookie.key in (&#34;ltuid&#34;, &#34;account_id&#34;):
            return int(cookie.value)

    return None</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.lang"><code class="name">var <span class="ident">lang</span> :str</code></dt>
<dd>
<div class="desc"><p>The default language, defaults to "en-us"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lang(self) -&gt; str:
    &#34;&#34;&#34;The default language, defaults to &#34;en-us&#34; &#34;&#34;&#34;
    return self._lang</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.session"><code class="name">var <span class="ident">session</span> :aiohttp.client.ClientSession</code></dt>
<dd>
<div class="desc"><p>The current client session, created when needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session(self) -&gt; aiohttp.ClientSession:
    &#34;&#34;&#34;The current client session, created when needed&#34;&#34;&#34;
    if self._session is None:
        self._session = aiohttp.ClientSession()

    return self._session</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.uid"><code class="name">var <span class="ident">uid</span> :Optional[int]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uid(self) -&gt; Optional[int]:
    return self._uid</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genshin.client.GenshinClient.calculator"><code class="name flex">
<span>def <span class="ident">calculator</span></span>(<span>self, *, lang:str=None) ><a title="genshin.models.calculator.CalculatorBuilder" href="models/calculator.html#genshin.models.calculator.CalculatorBuilder">CalculatorBuilder</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculator(self, *, lang: str = None) -&gt; CalculatorBuilder:
    &#34;&#34;&#34;Calculate the resources needed to level up various equipment.

    :param lang: The language to use
    &#34;&#34;&#34;
    return CalculatorBuilder(self, lang=lang)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.claim_daily_reward"><code class="name flex">
<span>async def <span class="ident">claim_daily_reward</span></span>(<span>self, *, lang:str=None, reward:bool=True) >Optional[<a title="genshin.models.daily.DailyReward" href="models/daily.html#genshin.models.daily.DailyReward">DailyReward</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
<dt><strong><code>reward</code></strong></dt>
<dd><p>Whether to also fetch the claimed reward</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def claim_daily_reward(
    self, *, lang: str = None, reward: bool = True
) -&gt; Optional[DailyReward]:
    &#34;&#34;&#34;Signs into hoyolab and claims the daily reward.

    :param lang: The language to use
    :param reward: Whether to also fetch the claimed reward
    &#34;&#34;&#34;
    await self.request_daily_reward(&#34;sign&#34;, method=&#34;POST&#34;, lang=lang)

    if not reward:
        return None

    info, rewards = await asyncio.gather(
        self.get_reward_info(lang=lang),
        self.get_monthly_rewards(lang=lang),
    )
    return rewards[info.claimed_rewards - 1]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.claimed_rewards"><code class="name flex">
<span>def <span class="ident">claimed_rewards</span></span>(<span>self, *, limit:int=None, lang:str=None) ><a title="genshin.paginator.DailyRewardPaginator" href="paginator.html#genshin.paginator.DailyRewardPaginator">DailyRewardPaginator</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>limit</code></strong></dt>
<dd><p>The maximum amount of rewards to get</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use - currently broken</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def claimed_rewards(self, *, limit: int = None, lang: str = None) -&gt; DailyRewardPaginator:
    &#34;&#34;&#34;Get all claimed rewards for the current user

    NOTE: Languages are currently broken,
    the language is based off the language used to claim the reward

    :param limit: The maximum amount of rewards to get
    :param lang: The language to use - currently broken
    &#34;&#34;&#34;
    return DailyRewardPaginator(self, limit=limit, lang=lang)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close the underlying aiohttp session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;Close the underlying aiohttp session&#34;&#34;&#34;
    if not self.session.closed:
        await self.session.close()</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.diary_log"><code class="name flex">
<span>def <span class="ident">diary_log</span></span>(<span>self, uid:int=None, *, mora:bool=False, month:int=None, limit:int=None, lang:str=None) ><a title="genshin.paginator.DiaryPaginator" href="paginator.html#genshin.paginator.DiaryPaginator">DiaryPaginator</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>client</code></strong></dt>
<dd><p>A client for making http requests</p></dd>
<dt><strong><code>uid</code></strong></dt>
<dd><p>Genshin uid of the currently logged-in user</p></dd>
<dt><strong><code>mora</code></strong></dt>
<dd><p>Whether the type of currency should be mora instead of primogems</p></dd>
<dt><strong><code>month</code></strong></dt>
<dd><p>The month in the year to see the history for</p></dd>
<dt><strong><code>limit</code></strong></dt>
<dd><p>The maximum amount of actions to get</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diary_log(
    self,
    uid: int = None,
    *,
    mora: bool = False,
    month: int = None,
    limit: int = None,
    lang: str = None,
) -&gt; DiaryPaginator:
    &#34;&#34;&#34;Create a new daily reward pagintor

    :param client: A client for making http requests
    :param uid: Genshin uid of the currently logged-in user
    :param mora: Whether the type of currency should be mora instead of primogems
    :param month: The month in the year to see the history for
    :param limit: The maximum amount of actions to get
    :param lang: The language to use
    &#34;&#34;&#34;
    type = 2 if mora else 1
    return DiaryPaginator(self, uid, type, month, limit, lang)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.fetch_banner_ids"><code class="name flex">
<span>async def <span class="ident">fetch_banner_ids</span></span>(<span>self) >List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch banner ids from a user-mantained repo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_banner_ids(self) -&gt; List[str]:
    &#34;&#34;&#34;Fetch banner ids from a user-mantained repo&#34;&#34;&#34;
    url = &#34;https://raw.githubusercontent.com/thesadru/genshindata/master/banner_ids.txt&#34;
    async with self.session.get(url) as r:
        data = await r.text()
    return data.splitlines()</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.genshin_accounts"><code class="name flex">
<span>async def <span class="ident">genshin_accounts</span></span>(<span>self, *, lang:str=None) >List[<a title="genshin.models.hoyolab.GenshinAccount" href="models/hoyolab.html#genshin.models.hoyolab.GenshinAccount">GenshinAccount</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the genshin accounts of the currently logged-in user</p>
<p>:params lang: The language to use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def genshin_accounts(self, *, lang: str = None) -&gt; List[GenshinAccount]:
    &#34;&#34;&#34;Get the genshin accounts of the currently logged-in user

    :params lang: The language to use
    &#34;&#34;&#34;
    # TODO: Account for honkai accounts

    # fmt: off
    data = await self.request_hoyolab(
        &#34;binding/api/getUserGameRolesByCookie&#34;,
        lang=lang,
        cache=(&#34;accounts&#34;, self.hoyolab_uid)
    )
    # fmt: on
    return [GenshinAccount(**i) for i in data[&#34;list&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_activities"><code class="name flex">
<span>async def <span class="ident">get_activities</span></span>(<span>self, uid:int, *, lang:str=None) ><a title="genshin.models.activities.Activities" href="models/activities.html#genshin.models.activities.Activities">Activities</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>A Genshin uid</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_activities(self, uid: int, *, lang: str = None) -&gt; Activities:
    &#34;&#34;&#34;Get activities

    :param uid: A Genshin uid
    :param lang: The language to use
    &#34;&#34;&#34;
    server = recognize_server(uid)
    data = await self.request_game_record(
        &#34;genshin/api/activities&#34;,
        lang=lang,
        params=dict(server=server, role_id=uid),
        cache=(&#34;activities&#34;, uid),
    )
    return Activities(**data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_banner_details"><code class="name flex">
<span>async def <span class="ident">get_banner_details</span></span>(<span>self, banner_ids:List[str]=None, *, lang:str=None) >List[<a title="genshin.models.wish.BannerDetails" href="models/wish.html#genshin.models.wish.BannerDetails">BannerDetails</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>banner_ids</code></strong></dt>
<dd><p>A list of banner ids, implicitly fetched when not provided</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_banner_details(
    self, banner_ids: List[str] = None, *, lang: str = None
) -&gt; List[BannerDetails]:
    &#34;&#34;&#34;Get all banner details at once in a batch

    :param banner_ids: A list of banner ids, implicitly fetched when not provided
    :param lang: The language to use
    &#34;&#34;&#34;
    try:
        banner_ids = banner_ids or get_banner_ids()
    except FileNotFoundError:
        banner_ids = []

    if len(banner_ids) &lt; 3:
        banner_ids = await self.fetch_banner_ids()

    data = await asyncio.gather(*(self._get_banner_details(i, lang=lang) for i in banner_ids))
    return list(data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_banner_names"><code class="name flex">
<span>async def <span class="ident">get_banner_names</span></span>(<span>self, *, lang:str=None, authkey:str=None) >Dict[Literal[100,200,301,302,400],str]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>The authkey to use when requesting data</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_banner_names(
    self, *, lang: str = None, authkey: str = None
) -&gt; Dict[BannerType, str]:
    &#34;&#34;&#34;Get a list of banner names

    :param lang: The language to use
    :param authkey: The authkey to use when requesting data
    &#34;&#34;&#34;
    func = perm_cache((&#34;banners&#34;, lang or self.lang), self.request_gacha_info)
    data = await func(
        &#34;getConfigList&#34;,
        lang=lang,
        authkey=authkey,
    )
    return {int(i[&#34;key&#34;]): i[&#34;name&#34;] for i in data[&#34;gacha_type_list&#34;]}  # type: ignore</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_calculator_artifacts"><code class="name flex">
<span>async def <span class="ident">get_calculator_artifacts</span></span>(<span>self, *, query:str=None, pos:int=1, rarities:Sequence[int]=None, lang:str=None) >List[<a title="genshin.models.calculator.CalculatorArtifact" href="models/calculator.html#genshin.models.calculator.CalculatorArtifact">CalculatorArtifact</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>query</code></strong></dt>
<dd><p>A query to use when searching; incompatible with other filters</p></dd>
<dt><strong><code>pos</code></strong></dt>
<dd><p>The slot position of the returned weapon</p></dd>
<dt><strong><code>rarities</code></strong></dt>
<dd><p>The rarities of returned artifacts</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_calculator_artifacts(
    self,
    *,
    query: str = None,
    pos: int = 1,
    rarities: Sequence[int] = None,
    lang: str = None,
) -&gt; List[CalculatorArtifact]:
    &#34;&#34;&#34;Get all artifacts provided by the Enhancement Progression Calculator

    :param query: A query to use when searching; incompatible with other filters
    :param pos: The slot position of the returned weapon
    :param rarities: The rarities of returned artifacts
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self._get_calculator_items(
        &#34;reliquary&#34;,
        lang=lang,
        query=query,
        filters=dict(
            reliquary_cat_id=pos,
            reliquary_levels=rarities or [],
        ),
    )
    return [CalculatorArtifact(**i) for i in data]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_calculator_characters"><code class="name flex">
<span>async def <span class="ident">get_calculator_characters</span></span>(<span>self, *, query:str=None, elements:Sequence[int]=None, weapon_types:Sequence[int]=None, include_traveler:bool=False, sync:Union[int,bool]=False, lang:str=None) >List[<a title="genshin.models.calculator.CalculatorCharacter" href="models/calculator.html#genshin.models.calculator.CalculatorCharacter">CalculatorCharacter</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>query</code></strong></dt>
<dd><p>A query to use when searching; incompatible with other filters</p></dd>
<dt><strong><code>elements</code></strong></dt>
<dd><p>The elements of returned characters - refer to <cite>.models.CALCULATOR_ELEMENTS</cite></p></dd>
<dt><strong><code>weapon_types</code></strong></dt>
<dd><p>The weapon types of returned characters - refer to <cite>.models.CALCULATOR_WEAPON_TYPES</cite></p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_calculator_characters(
    self,
    *,
    query: str = None,
    elements: Sequence[int] = None,
    weapon_types: Sequence[int] = None,
    include_traveler: bool = False,
    sync: Union[int, bool] = False,
    lang: str = None,
) -&gt; List[CalculatorCharacter]:
    &#34;&#34;&#34;Get all characters provided by the Enhancement Progression Calculator

    :param query: A query to use when searching; incompatible with other filters
    :param elements: The elements of returned characters - refer to `.models.CALCULATOR_ELEMENTS`
    :param weapon_types: The weapon types of returned characters - refer to `.models.CALCULATOR_WEAPON_TYPES`
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self._get_calculator_items(
        &#34;avatar&#34;,
        lang=lang,
        is_all=include_traveler,
        sync=sync,
        query=query,
        filters=dict(
            element_attr_ids=elements or [],
            weapon_cat_ids=weapon_types or [],
        ),
    )
    return [CalculatorCharacter(**i) for i in data]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_calculator_weapons"><code class="name flex">
<span>async def <span class="ident">get_calculator_weapons</span></span>(<span>self, *, query:str=None, types:Sequence[int]=None, rarities:Sequence[int]=None, lang:str=None) >List[<a title="genshin.models.calculator.CalculatorWeapon" href="models/calculator.html#genshin.models.calculator.CalculatorWeapon">CalculatorWeapon</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>query</code></strong></dt>
<dd><p>A query to use when searching; incompatible with other filters</p></dd>
<dt><strong><code>types</code></strong></dt>
<dd><p>The types of returned weapons - refer to <cite>.models.CALCULATOR_WEAPON_TYPES</cite></p></dd>
<dt><strong><code>rarities</code></strong></dt>
<dd><p>The rarities of returned weapons</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_calculator_weapons(
    self,
    *,
    query: str = None,
    types: Sequence[int] = None,
    rarities: Sequence[int] = None,
    lang: str = None,
) -&gt; List[CalculatorWeapon]:
    &#34;&#34;&#34;Get all weapons provided by the Enhancement Progression Calculator

    :param query: A query to use when searching; incompatible with other filters
    :param types: The types of returned weapons - refer to `.models.CALCULATOR_WEAPON_TYPES`
    :param rarities: The rarities of returned weapons
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self._get_calculator_items(
        &#34;weapon&#34;,
        lang=lang,
        query=query,
        filters=dict(
            weapon_cat_ids=types or [],
            weapon_levels=rarities or [],
        ),
    )
    return [CalculatorWeapon(**i) for i in data]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_character_details"><code class="name flex">
<span>async def <span class="ident">get_character_details</span></span>(<span>self, character_id:int, *, uid:int=None, lang:str=None) ><a title="genshin.models.calculator.CalculatorCharacterDetails" href="models/calculator.html#genshin.models.calculator.CalculatorCharacterDetails">CalculatorCharacterDetails</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_character_details(
    self,
    character_id: int,
    *,
    uid: int = None,
    lang: str = None,
) -&gt; CalculatorCharacterDetails:
    &#34;&#34;&#34;Get the weapon, artifacts and talents of a character

    Not related to the Battle Chronicle. This data is always private.

    :param lang: The language to use
    &#34;&#34;&#34;
    params = dict(avatar_id=character_id)
    params.update(await self._complete_uid(uid))

    data = await self.request_calculator(
        &#34;sync/avatar/detail&#34;,
        method=&#34;GET&#34;,
        lang=lang,
        params=params,
    )
    return CalculatorCharacterDetails(**data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_character_talents"><code class="name flex">
<span>async def <span class="ident">get_character_talents</span></span>(<span>self, character_id:int, *, lang:str=None) >List[<a title="genshin.models.calculator.CalculatorTalent" href="models/calculator.html#genshin.models.calculator.CalculatorTalent">CalculatorTalent</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_character_talents(
    self,
    character_id: int,
    *,
    lang: str = None,
) -&gt; List[CalculatorTalent]:
    &#34;&#34;&#34;Get the talents of a character

    This only gets the talent names, not their levels.
    Use `get_character_details` for precise information.

    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_calculator(
        &#34;avatar/skill_list&#34;,
        method=&#34;GET&#34;,
        lang=lang,
        params=dict(avatar_id=character_id),
    )
    return [CalculatorTalent(**i) for i in data[&#34;list&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_characters"><code class="name flex">
<span>async def <span class="ident">get_characters</span></span>(<span>self, uid:int, *, lang:str=None) >List[<a title="genshin.models.character.Character" href="models/character.html#genshin.models.character.Character">Character</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>A Genshin uid</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_characters(self, uid: int, *, lang: str = None) -&gt; List[Character]:
    &#34;&#34;&#34;Helper function to fetch characters from just their ids

    :param uid: A Genshin uid
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self._fetch_raw_characters(uid, lang=lang)
    return [Character(**i) for i in data]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_complete_artifact_set"><code class="name flex">
<span>async def <span class="ident">get_complete_artifact_set</span></span>(<span>self, artifact_id:int, *, lang:str=None) >List[<a title="genshin.models.calculator.CalculatorArtifact" href="models/calculator.html#genshin.models.calculator.CalculatorArtifact">CalculatorArtifact</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_complete_artifact_set(
    self,
    artifact_id: int,
    *,
    lang: str = None,
) -&gt; List[CalculatorArtifact]:
    &#34;&#34;&#34;Get all other artifacts that share a set with any given artifact

    Doesn&#39;t return the artifact passed into this function.

    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_calculator(
        &#34;reliquary/set&#34;,
        method=&#34;GET&#34;,
        lang=lang,
        params=dict(reliquary_id=artifact_id),
    )
    return [CalculatorArtifact(**i) for i in data[&#34;reliquary_list&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_diary"><code class="name flex">
<span>async def <span class="ident">get_diary</span></span>(<span>self, uid:int=None, *, month:int=None, lang:str=None) ><a title="genshin.models.diary.Diary" href="models/diary.html#genshin.models.diary.Diary">Diary</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>Genshin uid of the currently logged-in user</p></dd>
<dt><strong><code>month</code></strong></dt>
<dd><p>The month in the year to see the history for</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_diary(self, uid: int = None, *, month: int = None, lang: str = None) -&gt; Diary:
    &#34;&#34;&#34;Get a traveler&#39;s diary with earning details for the month

    :param uid: Genshin uid of the currently logged-in user
    :param month: The month in the year to see the history for
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_ledger(uid, month=month, lang=lang)
    return Diary(**data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_full_user"><code class="name flex">
<span>async def <span class="ident">get_full_user</span></span>(<span>self, uid:int, *, lang:str=None) ><a title="genshin.models.stats.FullUserStats" href="models/stats.html#genshin.models.stats.FullUserStats">FullUserStats</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>A Genshin uid</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_full_user(self, uid: int, *, lang: str = None) -&gt; FullUserStats:
    &#34;&#34;&#34;Get a user with all their possible data

    :param uid: A Genshin uid
    :param lang: The language to use
    &#34;&#34;&#34;
    user, abyss1, abyss2, activities = await asyncio.gather(
        self.get_user(uid, lang=lang),
        self.get_spiral_abyss(uid, lang=lang, previous=False),
        self.get_spiral_abyss(uid, lang=lang, previous=True),
        self.get_activities(uid, lang=lang),
    )
    abyss = {&#34;current&#34;: abyss1, &#34;previous&#34;: abyss2}
    return FullUserStats(**user.dict(), abyss=abyss, activities=activities)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_gacha_items"><code class="name flex">
<span>async def <span class="ident">get_gacha_items</span></span>(<span>self, *, server:str='os_asia', lang:str=None) >List[<a title="genshin.models.wish.GachaItem" href="models/wish.html#genshin.models.wish.GachaItem">GachaItem</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>server</code></strong></dt>
<dd><p>The server to request the items from</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_gacha_items(
    self, *, server: str = &#34;os_asia&#34;, lang: str = None
) -&gt; List[GachaItem]:
    &#34;&#34;&#34;Get the list of characters and weapons that can be gotten from the gacha.

    :param server: The server to request the items from
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_webstatic(
        f&#34;/hk4e/gacha_info/{server}/items/{lang or self.lang}.json&#34;, cache=False
    )
    return [GachaItem(**i) for i in data]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_map_info"><code class="name flex">
<span>async def <span class="ident">get_map_info</span></span>(<span>self, map_id:int=2, *, lang:str=None) ><a title="genshin.models.intermap.MapInfo" href="models/intermap.html#genshin.models.intermap.MapInfo">MapInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get info about an interactive map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_map_info(self, map_id: int = 2, *, lang: str = None) -&gt; MapInfo:
    &#34;&#34;&#34;Get info about an interactive map&#34;&#34;&#34;
    data = await self.request_map(
        &#34;map/info&#34;,
        lang=lang,
        map_id=map_id,
        static=True,
    )
    return MapInfo(**data[&#34;info&#34;])</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_map_labels"><code class="name flex">
<span>async def <span class="ident">get_map_labels</span></span>(<span>self, map_id:int=2, *, lang:str=None) >List[<a title="genshin.models.intermap.MapNode" href="models/intermap.html#genshin.models.intermap.MapNode">MapNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>map_id</code></strong></dt>
<dd><p>The id of the map</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_map_labels(self, map_id: int = 2, *, lang: str = None) -&gt; List[MapNode]:
    &#34;&#34;&#34;Get the map tree of all categories &amp; lables of map points

    :param map_id: The id of the map
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_map(&#34;map/label/tree&#34;, lang=lang, map_id=map_id, static=True)
    return [MapNode(**i) for i in data[&#34;tree&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_map_locations"><code class="name flex">
<span>async def <span class="ident">get_map_locations</span></span>(<span>self, map_id:int=2, *, lang:str=None) >List[<a title="genshin.models.intermap.MapLocation" href="models/intermap.html#genshin.models.intermap.MapLocation">MapLocation</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>map_id</code></strong></dt>
<dd><p>The id of the map</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_map_locations(self, map_id: int = 2, *, lang: str = None) -&gt; List[MapLocation]:
    &#34;&#34;&#34;Get a list of all locations on a map

    :param map_id: The id of the map
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_map(&#34;map/map_anchor/list&#34;, lang=lang, map_id=map_id, static=True)

    return [MapLocation(**i) for i in data[&#34;list&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_map_points"><code class="name flex">
<span>async def <span class="ident">get_map_points</span></span>(<span>self, map_id:int=2, *, lang:str=None) >Tuple[List[<a title="genshin.models.intermap.MapNode" href="models/intermap.html#genshin.models.intermap.MapNode">MapNode</a>],List[<a title="genshin.models.intermap.MapPoint" href="models/intermap.html#genshin.models.intermap.MapPoint">MapPoint</a>]]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>map_id</code></strong></dt>
<dd><p>The id of the map</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_map_points(
    self, map_id: int = 2, *, lang: str = None
) -&gt; Tuple[List[MapNode], List[MapPoint]]:
    &#34;&#34;&#34;Get a tuple of all map lables and map points

    :param map_id: The id of the map
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_map(&#34;map/point/list&#34;, lang=lang, map_id=map_id, static=True)

    labels = [MapNode(**i) for i in data[&#34;label_list&#34;]]
    points = [MapPoint(**i) for i in data[&#34;point_list&#34;]]

    return labels, points</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_monthly_rewards"><code class="name flex">
<span>async def <span class="ident">get_monthly_rewards</span></span>(<span>self, *, lang:str=None) >List[<a title="genshin.models.daily.DailyReward" href="models/daily.html#genshin.models.daily.DailyReward">DailyReward</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_monthly_rewards(self, *, lang: str = None) -&gt; List[DailyReward]:
    &#34;&#34;&#34;Get a list of all availible rewards for the current month

    :param lang: The language to use
    &#34;&#34;&#34;
    func = perm_cache(
        (&#34;rewards&#34;, datetime.utcnow().month, lang or self.lang),
        self.request_daily_reward,
    )
    data = await func(&#34;home&#34;, lang=lang)
    return [DailyReward(**i) for i in data[&#34;awards&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_notes"><code class="name flex">
<span>async def <span class="ident">get_notes</span></span>(<span>self, uid:int, *, lang:str=None) ><a title="genshin.models.notes.Notes" href="models/notes.html#genshin.models.notes.Notes">Notes</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>A Genshin uid</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_notes(self, uid: int, *, lang: str = None) -&gt; Notes:
    &#34;&#34;&#34;Get the real-time notes.

    :param uid: A Genshin uid
    :param lang: The language to use
    &#34;&#34;&#34;
    server = recognize_server(uid)
    data = await self.request_game_record(
        &#34;genshin/api/dailyNote&#34;,
        lang=lang,
        params=dict(server=server, role_id=uid),
    )
    return Notes(**data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_partial_user"><code class="name flex">
<span>async def <span class="ident">get_partial_user</span></span>(<span>self, uid:int, *, lang:str=None) ><a title="genshin.models.stats.PartialUserStats" href="models/stats.html#genshin.models.stats.PartialUserStats">PartialUserStats</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>A Genshin uid</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_partial_user(self, uid: int, *, lang: str = None) -&gt; PartialUserStats:
    &#34;&#34;&#34;Helper function to get a user without any equipment

    :param uid: A Genshin uid
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self._fetch_raw_user(uid, lang=lang)
    return PartialUserStats(**data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_recommended_users"><code class="name flex">
<span>async def <span class="ident">get_recommended_users</span></span>(<span>self, *, limit:int=200) >List[<a title="genshin.models.hoyolab.SearchUser" href="models/hoyolab.html#genshin.models.hoyolab.SearchUser">SearchUser</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>limit</code></strong></dt>
<dd><p>The maximum amount of users to return</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_recommended_users(self, *, limit: int = 200) -&gt; List[SearchUser]:
    &#34;&#34;&#34;Get a list of recommended active users

    :param limit: The maximum amount of users to return
    &#34;&#34;&#34;
    data = await self.request_hoyolab(
        &#34;community/user/wapi/recommendActive&#34;,
        params=dict(page_size=limit),
    )
    return [SearchUser(**i[&#34;user&#34;]) for i in data[&#34;list&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_record_card"><code class="name flex">
<span>async def <span class="ident">get_record_card</span></span>(<span>self, hoyolab_uid:int=None, *, lang:str=None) ><a title="genshin.models.hoyolab.RecordCard" href="models/hoyolab.html#genshin.models.hoyolab.RecordCard">RecordCard</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>hoyolab_uid</code></strong></dt>
<dd><p>A hoyolab uid</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_record_card(self, hoyolab_uid: int = None, *, lang: str = None) -&gt; RecordCard:
    &#34;&#34;&#34;Get a user&#39;s record card

    :param hoyolab_uid: A hoyolab uid
    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_game_record(
        &#34;card/wapi/getGameRecordCard&#34;,
        lang=lang,
        params=dict(uid=hoyolab_uid or self.hoyolab_uid),
        cache=(&#34;record&#34;, hoyolab_uid),
        cache_check=lambda data: len(data[&#34;list&#34;]) &gt; 0,
    )
    cards = data[&#34;list&#34;]
    if not cards:
        raise errors.DataNotPublic({&#34;retcode&#34;: 10102})

    return RecordCard(**cards[0])</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_reward_info"><code class="name flex">
<span>async def <span class="ident">get_reward_info</span></span>(<span>self, *, lang:str=None) ><a title="genshin.models.daily.DailyRewardInfo" href="models/daily.html#genshin.models.daily.DailyRewardInfo">DailyRewardInfo</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_reward_info(self, *, lang: str = None) -&gt; DailyRewardInfo:
    &#34;&#34;&#34;Get the daily reward info for the current user

    :param lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_daily_reward(&#34;info&#34;, lang=lang)
    return DailyRewardInfo(data[&#34;is_sign&#34;], data[&#34;total_sign_day&#34;])</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_spiral_abyss"><code class="name flex">
<span>async def <span class="ident">get_spiral_abyss</span></span>(<span>self, uid:int, *, previous:bool=False, lang:str=None) ><a title="genshin.models.abyss.SpiralAbyss" href="models/abyss.html#genshin.models.abyss.SpiralAbyss">SpiralAbyss</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>A Genshin uid</p></dd>
<dt><strong><code>previous</code></strong></dt>
<dd><p>Whether to get the record of the previous spiral abyss</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_spiral_abyss(
    self, uid: int, *, previous: bool = False, lang: str = None
) -&gt; SpiralAbyss:
    &#34;&#34;&#34;Get spiral abyss runs

    :param uid: A Genshin uid
    :param previous: Whether to get the record of the previous spiral abyss
    :param lang: The language to use
    &#34;&#34;&#34;
    server = recognize_server(uid)
    schedule_type = 2 if previous else 1
    data = await self.request_game_record(
        &#34;genshin/api/spiralAbyss&#34;,
        lang=lang,
        params=dict(role_id=uid, server=server, schedule_type=schedule_type),
        cache=(&#34;abyss&#34;, uid, schedule_type),
    )
    return SpiralAbyss(**data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.get_user"><code class="name flex">
<span>async def <span class="ident">get_user</span></span>(<span>self, uid:int, *, lang:str=None) ><a title="genshin.models.stats.UserStats" href="models/stats.html#genshin.models.stats.UserStats">UserStats</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>uid</code></strong></dt>
<dd><p>A Genshin uid</p></dd>
<dt><strong><code>character_ids</code></strong></dt>
<dd><p>The ids of characters you want to fetch</p></dd>
<dt><strong><code>all_characters</code></strong></dt>
<dd><p>Whether to get every single character a user has. Discouraged.</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_user(self, uid: int, *, lang: str = None) -&gt; UserStats:
    &#34;&#34;&#34;Get a user&#39;s stats and characters

    :param uid: A Genshin uid
    :param character_ids: The ids of characters you want to fetch
    :param all_characters: Whether to get every single character a user has. Discouraged.
    :param lang: The language to use
    &#34;&#34;&#34;
    data, characters = await asyncio.gather(
        self._fetch_raw_user(uid, lang=lang),
        self._fetch_raw_characters(uid, lang=lang),
    )
    data[&#34;avatars&#34;] = characters

    return UserStats(**data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.init"><code class="name flex">
<span>async def <span class="ident">init</span></span>(<span>self, lang:str=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def init(self, lang: str = None):
    &#34;&#34;&#34;Request all static &amp; permanent endpoints to not require them later

    :param lang: The language to use
    &#34;&#34;&#34;
    lang = lang or self.lang

    await asyncio.gather(
        self.get_banner_names(lang=lang),
        self.get_banner_details(lang=lang),
        self.get_monthly_rewards(),
        self._get_transaction_reasons(lang=lang),
        self._fetch_mi18n(),
    )</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.login_with_ticket"><code class="name flex">
<span>async def <span class="ident">login_with_ticket</span></span>(<span>self, login_ticket:str='') >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Complete cookies using a login ticket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def login_with_ticket(self, login_ticket: str = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;Complete cookies using a login ticket&#34;&#34;&#34;
    url = &#34;https://webapi-os.account.hoyoverse.com/Api/cookie_accountinfo_by_loginticket&#34;
    async with self.session.get(url, params=dict(login_ticket=login_ticket)) as r:
        r.raise_for_status()</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.redeem_code"><code class="name flex">
<span>async def <span class="ident">redeem_code</span></span>(<span>self, code:str, uid:int=None, *, lang:str=None) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>code</code></strong></dt>
<dd><p>The code to redeem</p></dd>
<dt><strong><code>uid</code></strong></dt>
<dd><p>The specific uid to redeem for</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def redeem_code(self, code: str, uid: int = None, *, lang: str = None) -&gt; None:
    &#34;&#34;&#34;Redeems a gift code for the current user

    :param code: The code to redeem
    :param uid: The specific uid to redeem for
    :param lang: The language to use
    &#34;&#34;&#34;
    # do note that this endpoint is very quirky, can&#39;t really make this pretty
    if uid is not None:
        server = recognize_server(uid)
        lang = create_short_lang_code(lang or self.lang)
        await self.request(
            &#34;https://hk4e-api-os.hoyoverse.com/common/apicdkey/api/webExchangeCdkey&#34;,
            params=dict(
                uid=uid,
                region=server,
                cdkey=code,
                game_biz=&#34;hk4e_global&#34;,
                lang=lang,
            ),
        )
        return

    accounts = [a for a in await self.genshin_accounts() if a.level &gt;= 10]

    for i, account in enumerate(accounts):
        # there&#39;s a ratelimit of 1 request every 5 seconds
        if i:
            await asyncio.sleep(5)

        await self.redeem_code(code, account.uid, lang=lang)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request"><code class="name flex">
<span>async def <span class="ident">request</span></span>(<span>self, url:Union[str,URL], method:str='GET', *, headers:Dict[str,Any]=None, **kwargs:Any) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request and return a parsed json response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@handle_ratelimits()
async def request(
    self,
    url: Union[str, URL],
    method: str = &#34;GET&#34;,
    *,
    headers: Dict[str, Any] = None,
    **kwargs: Any,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request and return a parsed json response&#34;&#34;&#34;
    asyncio.create_task(self._fetch_mi18n())

    headers = headers or {}
    headers[&#34;User-Agent&#34;] = self.USER_AGENT

    await self._request_hook(method, url, headers=headers, **kwargs)

    async with self.session.request(method, url, headers=headers, **kwargs) as r:
        r.raise_for_status()
        data = await r.json()

    if data[&#34;retcode&#34;] == 0:
        return data[&#34;data&#34;]

    errors.raise_for_retcode(data)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_calculator"><code class="name flex">
<span>async def <span class="ident">request_calculator</span></span>(<span>self, endpoint:str, *, method:str='POST', lang:str=None, params:Dict[str,Any]=None, json:Dict[str,Any]=None, **kwargs:Any) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards the calculator endpoint</p>
<p>Calculator database and resource calculation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_calculator(
    self,
    endpoint: str,
    *,
    method: str = &#34;POST&#34;,
    lang: str = None,
    params: Dict[str, Any] = None,
    json: Dict[str, Any] = None,
    **kwargs: Any,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request towards the calculator endpoint

    Calculator database and resource calculation
    &#34;&#34;&#34;
    params = params or {}
    json = json or {}

    if not self.cookies:
        raise RuntimeError(&#34;No cookies provided&#34;)

    url = URL(self.CALCULATOR_URL).join(URL(endpoint))

    if method == &#34;GET&#34;:
        params[&#34;lang&#34;] = lang or self.lang
        json = None
    else:
        json[&#34;lang&#34;] = lang or self.lang

    return await self.request(url, method, params=params, json=json, **kwargs)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_daily_reward"><code class="name flex">
<span>async def <span class="ident">request_daily_reward</span></span>(<span>self, endpoint:str, *, method:str='GET', lang:str=None, params:Dict[str,Any]=None, **kwargs:Any) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards the daily reward endpoint</p>
<p>Daily reward claiming and history</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_daily_reward(
    self,
    endpoint: str,
    *,
    method: str = &#34;GET&#34;,
    lang: str = None,
    params: Dict[str, Any] = None,
    **kwargs: Any,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request towards the daily reward endpoint

    Daily reward claiming and history
    &#34;&#34;&#34;
    params = params or {}

    if not self.cookies:
        raise RuntimeError(&#34;No cookies provided&#34;)

    url = URL(self.REWARD_URL).join(URL(endpoint))

    params[&#34;lang&#34;] = lang or self.lang
    params[&#34;act_id&#34;] = self.ACT_ID

    return await self.request(url, method, params=params, **kwargs)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_gacha_info"><code class="name flex">
<span>async def <span class="ident">request_gacha_info</span></span>(<span>self, endpoint:str, *, method:str='GET', lang:str=None, authkey:Optional[str]=None, params:Dict[str,Any]=None, **kwargs:Any) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards the game info endpoint</p>
<p>Wish history related data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_gacha_info(
    self,
    endpoint: str,
    *,
    method: str = &#34;GET&#34;,
    lang: str = None,
    authkey: Optional[str] = None,
    params: Dict[str, Any] = None,
    **kwargs: Any,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request towards the game info endpoint

    Wish history related data
    &#34;&#34;&#34;
    params = params or {}
    authkey = authkey or self.authkey

    if authkey is None:
        raise RuntimeError(&#34;No authkey provided&#34;)

    base_url = URL(self.GACHA_INFO_URL)
    url = base_url.join(URL(endpoint))

    params[&#34;authkey_ver&#34;] = 1
    params[&#34;authkey&#34;] = unquote(authkey)
    params[&#34;lang&#34;] = create_short_lang_code(lang or self.lang)

    return await self.request(url, method, params=params, **kwargs)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_game_record"><code class="name flex">
<span>async def <span class="ident">request_game_record</span></span>(<span>self, endpoint:str, *, method:str='GET', cache:Tuple[Any,...]=None, cache_check:Callable[[Any],bool]=None, **kwargs:Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards the game record endpoint</p>
<p>User stats related data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_game_record(
    self,
    endpoint: str,
    *,
    method: str = &#34;GET&#34;,
    cache: Tuple[Any, ...] = None,
    cache_check: Callable[[Any], bool] = None,
    **kwargs: Any,
):
    &#34;&#34;&#34;Make a request towards the game record endpoint

    User stats related data
    &#34;&#34;&#34;
    # this is simply just an alias for shorter request endpoints
    url = URL(self.RECORD_URL).join(URL(endpoint))

    return await self.request_hoyolab(
        url, method=method, cache=cache, cache_check=cache_check, **kwargs
    )</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_hoyolab"><code class="name flex">
<span>async def <span class="ident">request_hoyolab</span></span>(<span>self, endpoint:Union[str,URL], *, method:str='GET', lang:str=None, cache:Tuple[Any,...]=None, cache_check:Callable[[Any],bool]=None, **kwargs:Any) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards misc hoyolabs api</p>
<p>Community related data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_hoyolab(
    self,
    endpoint: Union[str, URL],
    *,
    method: str = &#34;GET&#34;,
    lang: str = None,
    cache: Tuple[Any, ...] = None,
    cache_check: Callable[[Any], bool] = None,
    **kwargs: Any,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request towards misc hoyolabs api

    Community related data
    &#34;&#34;&#34;
    if cache:
        data = await self._check_cache(cache, cache_check, lang=lang)
        if data:
            return data

    if not self.cookies:
        raise RuntimeError(&#34;No cookies provided&#34;)
    if lang not in LANGS and lang is not None:
        raise ValueError(f&#34;{lang} is not a valid language, must be one of: &#34; + &#34;, &#34;.join(LANGS))

    url = URL(self.TAKUMI_URL).join(URL(endpoint))

    headers = {
        &#34;x-rpc-app_version&#34;: &#34;1.5.0&#34;,
        &#34;x-rpc-client_type&#34;: &#34;4&#34;,
        &#34;x-rpc-language&#34;: lang or self.lang,
        &#34;ds&#34;: generate_dynamic_secret(self.DS_SALT),
    }

    data = await self.request(url, method, headers=headers, **kwargs)

    if cache:
        await self._update_cache(data, cache, cache_check, lang=lang)

    return data</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_ledger"><code class="name flex">
<span>async def <span class="ident">request_ledger</span></span>(<span>self, uid:int=None, detail:bool=False, *, month:int=None, lang:str=None, params:Dict[str,Any]=None) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards the ys ledger endpoint</p>
<p>Traveler's diary related data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_ledger(
    self,
    uid: int = None,
    detail: bool = False,
    *,
    month: int = None,
    lang: str = None,
    params: Dict[str, Any] = None,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request towards the ys ledger endpoint

    Traveler&#39;s diary related data
    &#34;&#34;&#34;
    params = params or {}

    url = URL(self.DETAIL_LEDGER_URL if detail else self.INFO_LEDGER_URL)

    params.update(await self._complete_uid(uid))
    params[&#34;month&#34;] = month or datetime.now().month
    params[&#34;lang&#34;] = lang or self.lang

    return await self.request(url, params=params)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_map"><code class="name flex">
<span>async def <span class="ident">request_map</span></span>(<span>self, endpoint:str, *, method:str='GET', lang:str=None, map_id:int=2, static:bool=False, params:Dict[str,Any]=None, **kwargs) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards the map endpoint</p>
<p>Interactive map related data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_map(
    self,
    endpoint: str,
    *,
    method: str = &#34;GET&#34;,
    lang: str = None,
    map_id: int = 2,
    static: bool = False,
    params: Dict[str, Any] = None,
    **kwargs,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request towards the map endpoint

    Interactive map related data
    &#34;&#34;&#34;
    params = params or {}

    base_url = self.STATIC_MAP_URL if static else self.MAP_URL
    url = URL(base_url).join(URL(endpoint))

    params[&#34;map_id&#34;] = map_id
    params[&#34;app_sn&#34;] = &#34;ys_obc&#34;
    params[&#34;lang&#34;] = lang or self.lang

    return await self.request(url, method, params=params, **kwargs)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_transaction"><code class="name flex">
<span>async def <span class="ident">request_transaction</span></span>(<span>self, endpoint:str, *, method:str='GET', lang:str=None, authkey:Optional[str]=None, params:Dict[str,Any]=None, **kwargs:Any) >Dict[str,Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request towards the transaction log endpoint</p>
<p>Transaction related data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_transaction(
    self,
    endpoint: str,
    *,
    method: str = &#34;GET&#34;,
    lang: str = None,
    authkey: Optional[str] = None,
    params: Dict[str, Any] = None,
    **kwargs: Any,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Make a request towards the transaction log endpoint

    Transaction related data
    &#34;&#34;&#34;
    params = params or {}
    authkey = authkey or self.authkey

    if authkey is None:
        raise RuntimeError(&#34;No authkey provided&#34;)

    base_url = URL(self.YSULOG_URL)
    url = base_url.join(URL(endpoint))

    params[&#34;authkey_ver&#34;] = 1
    params[&#34;sign_type&#34;] = 2
    params[&#34;authkey&#34;] = unquote(authkey)
    params[&#34;lang&#34;] = create_short_lang_code(lang or self.lang)

    return await self.request(url, method, params=params, **kwargs)</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.request_webstatic"><code class="name flex">
<span>async def <span class="ident">request_webstatic</span></span>(<span>self, url:Union[str,URL], *, headers:Dict[str,Any]=None, cache:bool=True, **kwargs:Any) >Any</span>
</code></dt>
<dd>
<div class="desc"><p>Request a static json file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_webstatic(
    self,
    url: Union[str, URL],
    *,
    headers: Dict[str, Any] = None,
    cache: bool = True,
    **kwargs: Any,
) -&gt; Any:
    &#34;&#34;&#34;Request a static json file&#34;&#34;&#34;
    url = URL(self.WEBSTATIC_URL).join(URL(url))

    data = get_from_static_cache(str(url))
    if data is not None:
        return data

    headers = headers or {}
    headers[&#34;user-agent&#34;] = self.USER_AGENT

    async with self.session.get(url, headers=headers, **kwargs) as r:
        r.raise_for_status()
        data = await r.json()

    if cache:
        save_to_static_cache(str(url), data)

    return data</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.search_users"><code class="name flex">
<span>async def <span class="ident">search_users</span></span>(<span>self, keyword:str, *, lang:str=None) >List[<a title="genshin.models.hoyolab.SearchUser" href="models/hoyolab.html#genshin.models.hoyolab.SearchUser">SearchUser</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>keyword</code></strong></dt>
<dd><p>The keyword to search with</p></dd>
</dl>
<h2 id="params">params:</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def search_users(self, keyword: str, *, lang: str = None) -&gt; List[SearchUser]:
    &#34;&#34;&#34;Search hoyolab users

    :param keyword: The keyword to search with
    :params lang: The language to use
    &#34;&#34;&#34;
    data = await self.request_hoyolab(
        &#34;community/search/wapi/search/user&#34;,
        lang=lang,
        params=dict(keyword=keyword, page_size=20),
        cache=(&#34;search&#34;, keyword),
    )
    return [SearchUser(**i[&#34;user&#34;]) for i in data[&#34;list&#34;]]</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.set_authkey"><code class="name flex">
<span>def <span class="ident">set_authkey</span></span>(<span>self, authkey:str=None) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>An authkey, a url containing an authkey or a path towards a logfile</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The new authkey</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_authkey(self, authkey: str = None) -&gt; None:
    &#34;&#34;&#34;Sets an authkey for wish &amp; transaction logs

    :param authkey: An authkey, a url containing an authkey or a path towards a logfile
    :returns: The new authkey
    &#34;&#34;&#34;
    if authkey is None or os.path.isfile(authkey):
        authkey = get_authkey(authkey)
    else:
        authkey = extract_authkey(authkey) or authkey

    self.authkey = authkey</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.set_browser_cookies"><code class="name flex">
<span>def <span class="ident">set_browser_cookies</span></span>(<span>self, browser:str=None) >Mapping[str,str]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>browser</code></strong></dt>
<dd><p>The browser to extract the cookies from</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The extracted cookies</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_browser_cookies(self, browser: str = None) -&gt; Mapping[str, str]:
    &#34;&#34;&#34;Extract cookies from your browser and set them as client cookies

    Avalible browsers: chrome, chromium, opera, edge, firefox

    :param browser: The browser to extract the cookies from
    :returns: The extracted cookies
    &#34;&#34;&#34;
    self.cookies = get_browser_cookies(browser)
    return self.cookies</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.set_cache"><code class="name flex">
<span>def <span class="ident">set_cache</span></span>(<span>self, maxsize:int, strategy:"Literal['FIFO','LFU','LRU','MRU','RR']"='LRU', *, ttl:int=None, getsizeof:Callable[[Any],float]=None) >MutableMapping[Any,Any]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>maxsize</code></strong></dt>
<dd><p>The maximum size of the cache</p></dd>
<dt><strong><code>strategy</code></strong></dt>
<dd><p>The cache strategy to use, defaults to Least-Recently-Used</p></dd>
<dt><strong><code>ttl</code></strong></dt>
<dd><p>The time to live of items, only works with LRU caches</p></dd>
<dt><strong><code>getsizeof</code></strong></dt>
<dd><p>Function that gets the size of any objecct, by default everything has size of 1</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The newly created cache</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cache(
    self,
    maxsize: int,
    strategy: Literal[&#34;FIFO&#34;, &#34;LFU&#34;, &#34;LRU&#34;, &#34;MRU&#34;, &#34;RR&#34;] = &#34;LRU&#34;,
    *,
    ttl: int = None,
    getsizeof: Callable[[Any], float] = None,
) -&gt; MutableMapping[Any, Any]:
    &#34;&#34;&#34;Create and set a new cache for http requests

    :param maxsize: The maximum size of the cache
    :param strategy: The cache strategy to use, defaults to Least-Recently-Used
    :param ttl: The time to live of items, only works with LRU caches
    :param getsizeof: Function that gets the size of any objecct, by default everything has size of 1
    :returns: The newly created cache
    &#34;&#34;&#34;
    import cachetools

    if ttl:
        if strategy != &#34;LRU&#34;:
            raise ValueError(&#34;TTL caches must use LRU&#34;)

        self.cache = cachetools.TTLCache(maxsize, ttl, getsizeof=getsizeof)
        return self.cache
    elif strategy == &#34;TTL&#34;:
        raise ValueError(&#34;TTL caches should be set using the ttl kwarg&#34;)

    cls_name = strategy + &#34;Cache&#34;
    if not hasattr(cachetools, cls_name):
        raise ValueError(f&#34;Invalid strategy: {strategy}&#34;)

    self.cache = getattr(cachetools, cls_name)(maxsize, getsizeof=getsizeof)
    return self.cache</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.set_cookies"><code class="name flex">
<span>def <span class="ident">set_cookies</span></span>(<span>self, cookies:Union[Mapping[str,Any],str]=None, **kwargs:Any) >Mapping[str,str]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns:</h2>
<dl>
<dd><p>The new cookies</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cookies(
    self, cookies: Union[Mapping[str, Any], str] = None, **kwargs: Any
) -&gt; Mapping[str, str]:
    &#34;&#34;&#34;Helper cookie setter that accepts cookie headers

    :returns: The new cookies
    &#34;&#34;&#34;
    if not bool(cookies) ^ bool(kwargs):
        raise TypeError(&#34;Cannot use both positional and keyword arguments at once&#34;)

    cookies = cookies or kwargs
    cookies = {morsel.key: morsel.value for morsel in SimpleCookie(cookies).values()}
    self.cookies = cookies
    return self.cookies</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.set_top_characters"><code class="name flex">
<span>async def <span class="ident">set_top_characters</span></span>(<span>self, character_ids:List[int], *, uid:int=None) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>character_ids</code></strong></dt>
<dd><p>IDs of characters to be shown</p></dd>
<dt><strong><code>uid</code></strong></dt>
<dd><p>Genshin uid of the currently logged-in user</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_top_characters(self, character_ids: List[int], *, uid: int = None) -&gt; None:
    &#34;&#34;&#34;Set the top 8 visible characters for the current user

    :param character_ids: IDs of characters to be shown
    :param uid: Genshin uid of the currently logged-in user
    &#34;&#34;&#34;
    json = dict(avatar_ids=character_ids)
    json.update(await self._complete_uid(uid, uid_key=&#34;role_id&#34;, server_key=&#34;server&#34;))
    await self.request_game_record(
        &#34;genshin/api/character/top&#34;,
        method=&#34;POST&#34;,
        json=json,
    )</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.set_visibility"><code class="name flex">
<span>async def <span class="ident">set_visibility</span></span>(<span>self, public:bool) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>public</code></strong></dt>
<dd><p>Whether the data should now be public</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_visibility(self, public: bool) -&gt; None:
    &#34;&#34;&#34;Sets your data to public or private.

    :param public: Whether the data should now be public
    &#34;&#34;&#34;
    await self.request_game_record(
        &#34;genshin/wapi/publishGameRecord&#34;,
        method=&#34;POST&#34;,
        json=dict(is_public=public, game_id=2),
    )</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.transaction_log"><code class="name flex">
<span>def <span class="ident">transaction_log</span></span>(<span>self, kind:Union[TransactionKind,List[TransactionKind]]=None, *, limit:int=None, lang:str=None, authkey:str=None, end_id:int=0) >Union[<a title="genshin.paginator.Transactions" href="paginator.html#genshin.paginator.Transactions">Transactions</a>[Any],<a title="genshin.paginator.MergedTransactions" href="paginator.html#genshin.paginator.MergedTransactions">MergedTransactions</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>kind</code></strong></dt>
<dd><p>The kind(s) of transactions to get</p></dd>
<dt><strong><code>limit</code></strong></dt>
<dd><p>The maximum amount of wishes to get</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>The authkey to use when requesting data</p></dd>
<dt><strong><code>end_id</code></strong></dt>
<dd><p>The ending id to start getting data from</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transaction_log(
    self,
    kind: Union[TransactionKind, List[TransactionKind]] = None,
    *,
    limit: int = None,
    lang: str = None,
    authkey: str = None,
    end_id: int = 0,
) -&gt; Union[Transactions[Any], MergedTransactions]:
    &#34;&#34;&#34;Get the transaction log of a user

    :param kind: The kind(s) of transactions to get
    :param limit: The maximum amount of wishes to get
    :param lang: The language to use
    :param authkey: The authkey to use when requesting data
    :param end_id: The ending id to start getting data from
    &#34;&#34;&#34;
    cls = Transactions if isinstance(kind, str) else MergedTransactions
    return cls(
        self,
        kind,  # type: ignore
        lang=lang,
        authkey=authkey,
        limit=limit,
        end_id=end_id,
    )</code></pre>
</details>
</dd>
<dt id="genshin.client.GenshinClient.wish_history"><code class="name flex">
<span>def <span class="ident">wish_history</span></span>(<span>self, banner_type:Union[BannerType,List[BannerType]]=None, *, limit:int=None, lang:str=None, authkey:str=None, end_id:int=0) >Union[<a title="genshin.paginator.WishHistory" href="paginator.html#genshin.paginator.WishHistory">WishHistory</a>,<a title="genshin.paginator.MergedWishHistory" href="paginator.html#genshin.paginator.MergedWishHistory">MergedWishHistory</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>banner_type</code></strong></dt>
<dd><p>The banner(s) from which to get the wishes</p></dd>
<dt><strong><code>limit</code></strong></dt>
<dd><p>The maximum amount of wishes to get</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The language to use</p></dd>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>The authkey to use when requesting data</p></dd>
<dt><strong><code>end_id</code></strong></dt>
<dd><p>The ending id to start getting data from</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wish_history(
    self,
    banner_type: Union[BannerType, List[BannerType]] = None,
    *,
    limit: int = None,
    lang: str = None,
    authkey: str = None,
    end_id: int = 0,
) -&gt; Union[WishHistory, MergedWishHistory]:
    &#34;&#34;&#34;Get the wish history of a user

    :param banner_type: The banner(s) from which to get the wishes
    :param limit: The maximum amount of wishes to get
    :param lang: The language to use
    :param authkey: The authkey to use when requesting data
    :param end_id: The ending id to start getting data from
    &#34;&#34;&#34;
    cls = WishHistory if isinstance(banner_type, int) else MergedWishHistory
    return cls(
        self,
        banner_type,  # type: ignore
        lang=lang,
        authkey=authkey,
        limit=limit,
        end_id=end_id,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="genshin.client.MultiCookieClient"><code class="flex name class">
<span>class <span class="ident">MultiCookieClient</span></span>
<span>(</span><span>cookie_list:Iterable[Mapping[str,str]]=None, *, lang:str='en-us', debug:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cookies</code></strong></dt>
<dd><p>The cookies used for authenticaation</p></dd>
<dt><strong><code>authkey</code></strong></dt>
<dd><p>The authkey used for paginators</p></dd>
<dt><strong><code>lang</code></strong></dt>
<dd><p>The default language</p></dd>
<dt><strong><code>debug</code></strong></dt>
<dd><p>Whether debug logs should be shown in stdout</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiCookieClient(GenshinClient):
    &#34;&#34;&#34;A Genshin Client which allows setting multiple cookies&#34;&#34;&#34;

    sessions: List[aiohttp.ClientSession]

    def __init__(
        self,
        cookie_list: Iterable[Mapping[str, str]] = None,
        *,
        lang: str = &#34;en-us&#34;,
        debug: bool = False,
    ) -&gt; None:
        self.sessions = []

        if cookie_list:
            self.set_cookies(cookie_list)

        super().__init__(lang=lang, debug=debug)

    @property
    def session(self) -&gt; aiohttp.ClientSession:
        &#34;&#34;&#34;The currently chosen session&#34;&#34;&#34;
        if not self.sessions:
            return aiohttp.ClientSession()

        return self.sessions[0]

    @property
    def cookies(self) -&gt; List[Mapping[str, str]]:
        &#34;&#34;&#34;A list of all cookies&#34;&#34;&#34;
        return [{m.key: m.value for m in s.cookie_jar} for s in self.sessions]

    @cookies.setter
    def cookies(self, cookies: List[Mapping[str, Any]]) -&gt; None:
        self.set_cookies(cookies)

    def set_cookies(
        self,
        cookie_list: Union[Iterable[Union[Mapping[str, Any], str]], str],
        clear: bool = True,
    ) -&gt; List[Mapping[str, str]]:
        &#34;&#34;&#34;Set a list of cookies

        :param cookie_list: A list of cookies or a json file containing cookies
        :param clear: Whether to clear all of the previous cookies
        &#34;&#34;&#34;
        if clear:
            self.sessions.clear()

        if isinstance(cookie_list, str):
            with open(cookie_list) as file:
                cookie_list = json_.load(file)

            if not isinstance(cookie_list, list):
                raise RuntimeError(&#34;Json file must contain a list of cookies&#34;)

        for cookies in cookie_list:
            session = aiohttp.ClientSession(cookies=SimpleCookie(cookies))
            self.sessions.append(session)

        return self.cookies

    def set_browser_cookies(self, *args: Any, **kwargs: Any) -&gt; NoReturn:
        raise RuntimeError(f&#34;{type(self).__name__} does not support browser cookies&#34;)

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the underlying aiohttp sessions&#34;&#34;&#34;
        tasks = [
            asyncio.create_task(session.close()) for session in self.sessions if not session.closed
        ]
        if tasks:
            await asyncio.wait(tasks)

        await super().close()

    async def request(
        self,
        url: Union[str, URL],
        method: str = &#34;GET&#34;,
        headers: Dict[str, Any] = None,
        **kwargs: Any,
    ) -&gt; Dict[str, Any]:
        headers = headers or {}
        headers[&#34;user-agent&#34;] = self.USER_AGENT

        for session in self.sessions.copy():
            async with session.request(method, url, headers=headers, **kwargs) as r:
                r.raise_for_status()
                data = await r.json()

            if data[&#34;retcode&#34;] == 0:
                return data[&#34;data&#34;]

            try:
                errors.raise_for_retcode(data)
            except errors.TooManyRequests:
                # move the ratelimited session to the end to let the ratelimit wear off
                session = self.sessions.pop(0)
                self.sessions.append(session)

        # if we&#39;re here it means we used up all our sessions so we must handle that
        msg = &#34;All cookies have hit their request limit of 30 accounts per day.&#34;
        raise errors.TooManyRequests({&#34;retcode&#34;: 10101}, msg)

    async def request_daily_reward(self, *args: Any, **kwargs: Any) -&gt; NoReturn:
        &#34;&#34;&#34;Helper overwrite to prevent nasty bugs&#34;&#34;&#34;
        raise RuntimeError(f&#34;{type(self).__name__} does not support daily reward endpoints&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="genshin.client.GenshinClient" href="#genshin.client.GenshinClient">GenshinClient</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="genshin.client.ChineseMultiCookieClient" href="#genshin.client.ChineseMultiCookieClient">ChineseMultiCookieClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="genshin.client.MultiCookieClient.sessions"><code class="name">var <span class="ident">sessions</span> :List[aiohttp.client.ClientSession]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="genshin.client.MultiCookieClient.cookies"><code class="name">var <span class="ident">cookies</span> :List[Mapping[str,str]]</code></dt>
<dd>
<div class="desc"><p>A list of all cookies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cookies(self) -&gt; List[Mapping[str, str]]:
    &#34;&#34;&#34;A list of all cookies&#34;&#34;&#34;
    return [{m.key: m.value for m in s.cookie_jar} for s in self.sessions]</code></pre>
</details>
</dd>
<dt id="genshin.client.MultiCookieClient.session"><code class="name">var <span class="ident">session</span> :aiohttp.client.ClientSession</code></dt>
<dd>
<div class="desc"><p>The currently chosen session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session(self) -&gt; aiohttp.ClientSession:
    &#34;&#34;&#34;The currently chosen session&#34;&#34;&#34;
    if not self.sessions:
        return aiohttp.ClientSession()

    return self.sessions[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genshin.client.MultiCookieClient.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close the underlying aiohttp sessions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;Close the underlying aiohttp sessions&#34;&#34;&#34;
    tasks = [
        asyncio.create_task(session.close()) for session in self.sessions if not session.closed
    ]
    if tasks:
        await asyncio.wait(tasks)

    await super().close()</code></pre>
</details>
</dd>
<dt id="genshin.client.MultiCookieClient.request_daily_reward"><code class="name flex">
<span>async def <span class="ident">request_daily_reward</span></span>(<span>self, *args:Any, **kwargs:Any) >NoReturn</span>
</code></dt>
<dd>
<div class="desc"><p>Helper overwrite to prevent nasty bugs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request_daily_reward(self, *args: Any, **kwargs: Any) -&gt; NoReturn:
    &#34;&#34;&#34;Helper overwrite to prevent nasty bugs&#34;&#34;&#34;
    raise RuntimeError(f&#34;{type(self).__name__} does not support daily reward endpoints&#34;)</code></pre>
</details>
</dd>
<dt id="genshin.client.MultiCookieClient.set_cookies"><code class="name flex">
<span>def <span class="ident">set_cookies</span></span>(<span>self, cookie_list:Union[Iterable[Union[Mapping[str,Any],str]],str], clear:bool=True) >List[Mapping[str,str]]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cookie_list</code></strong></dt>
<dd><p>A list of cookies or a json file containing cookies</p></dd>
<dt><strong><code>clear</code></strong></dt>
<dd><p>Whether to clear all of the previous cookies</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cookies(
    self,
    cookie_list: Union[Iterable[Union[Mapping[str, Any], str]], str],
    clear: bool = True,
) -&gt; List[Mapping[str, str]]:
    &#34;&#34;&#34;Set a list of cookies

    :param cookie_list: A list of cookies or a json file containing cookies
    :param clear: Whether to clear all of the previous cookies
    &#34;&#34;&#34;
    if clear:
        self.sessions.clear()

    if isinstance(cookie_list, str):
        with open(cookie_list) as file:
            cookie_list = json_.load(file)

        if not isinstance(cookie_list, list):
            raise RuntimeError(&#34;Json file must contain a list of cookies&#34;)

    for cookies in cookie_list:
        session = aiohttp.ClientSession(cookies=SimpleCookie(cookies))
        self.sessions.append(session)

    return self.cookies</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="genshin.client.GenshinClient" href="#genshin.client.GenshinClient">GenshinClient</a></b></code>:
<ul class="hlist">
<li><code><a title="genshin.client.GenshinClient.authkey" href="#genshin.client.GenshinClient.authkey">authkey</a></code></li>
<li><code><a title="genshin.client.GenshinClient.calculator" href="#genshin.client.GenshinClient.calculator">calculator</a></code></li>
<li><code><a title="genshin.client.GenshinClient.claim_daily_reward" href="#genshin.client.GenshinClient.claim_daily_reward">claim_daily_reward</a></code></li>
<li><code><a title="genshin.client.GenshinClient.claimed_rewards" href="#genshin.client.GenshinClient.claimed_rewards">claimed_rewards</a></code></li>
<li><code><a title="genshin.client.GenshinClient.debug" href="#genshin.client.GenshinClient.debug">debug</a></code></li>
<li><code><a title="genshin.client.GenshinClient.diary_log" href="#genshin.client.GenshinClient.diary_log">diary_log</a></code></li>
<li><code><a title="genshin.client.GenshinClient.fetch_banner_ids" href="#genshin.client.GenshinClient.fetch_banner_ids">fetch_banner_ids</a></code></li>
<li><code><a title="genshin.client.GenshinClient.genshin_accounts" href="#genshin.client.GenshinClient.genshin_accounts">genshin_accounts</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_activities" href="#genshin.client.GenshinClient.get_activities">get_activities</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_banner_details" href="#genshin.client.GenshinClient.get_banner_details">get_banner_details</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_banner_names" href="#genshin.client.GenshinClient.get_banner_names">get_banner_names</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_artifacts" href="#genshin.client.GenshinClient.get_calculator_artifacts">get_calculator_artifacts</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_characters" href="#genshin.client.GenshinClient.get_calculator_characters">get_calculator_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_weapons" href="#genshin.client.GenshinClient.get_calculator_weapons">get_calculator_weapons</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_character_details" href="#genshin.client.GenshinClient.get_character_details">get_character_details</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_character_talents" href="#genshin.client.GenshinClient.get_character_talents">get_character_talents</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_characters" href="#genshin.client.GenshinClient.get_characters">get_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_complete_artifact_set" href="#genshin.client.GenshinClient.get_complete_artifact_set">get_complete_artifact_set</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_diary" href="#genshin.client.GenshinClient.get_diary">get_diary</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_full_user" href="#genshin.client.GenshinClient.get_full_user">get_full_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_gacha_items" href="#genshin.client.GenshinClient.get_gacha_items">get_gacha_items</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_info" href="#genshin.client.GenshinClient.get_map_info">get_map_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_labels" href="#genshin.client.GenshinClient.get_map_labels">get_map_labels</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_locations" href="#genshin.client.GenshinClient.get_map_locations">get_map_locations</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_points" href="#genshin.client.GenshinClient.get_map_points">get_map_points</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_monthly_rewards" href="#genshin.client.GenshinClient.get_monthly_rewards">get_monthly_rewards</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_notes" href="#genshin.client.GenshinClient.get_notes">get_notes</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_partial_user" href="#genshin.client.GenshinClient.get_partial_user">get_partial_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_recommended_users" href="#genshin.client.GenshinClient.get_recommended_users">get_recommended_users</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_record_card" href="#genshin.client.GenshinClient.get_record_card">get_record_card</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_reward_info" href="#genshin.client.GenshinClient.get_reward_info">get_reward_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_spiral_abyss" href="#genshin.client.GenshinClient.get_spiral_abyss">get_spiral_abyss</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_user" href="#genshin.client.GenshinClient.get_user">get_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.hoyolab_uid" href="#genshin.client.GenshinClient.hoyolab_uid">hoyolab_uid</a></code></li>
<li><code><a title="genshin.client.GenshinClient.init" href="#genshin.client.GenshinClient.init">init</a></code></li>
<li><code><a title="genshin.client.GenshinClient.lang" href="#genshin.client.GenshinClient.lang">lang</a></code></li>
<li><code><a title="genshin.client.GenshinClient.login_with_ticket" href="#genshin.client.GenshinClient.login_with_ticket">login_with_ticket</a></code></li>
<li><code><a title="genshin.client.GenshinClient.redeem_code" href="#genshin.client.GenshinClient.redeem_code">redeem_code</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request" href="#genshin.client.GenshinClient.request">request</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_calculator" href="#genshin.client.GenshinClient.request_calculator">request_calculator</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_gacha_info" href="#genshin.client.GenshinClient.request_gacha_info">request_gacha_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_game_record" href="#genshin.client.GenshinClient.request_game_record">request_game_record</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_hoyolab" href="#genshin.client.GenshinClient.request_hoyolab">request_hoyolab</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_ledger" href="#genshin.client.GenshinClient.request_ledger">request_ledger</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_map" href="#genshin.client.GenshinClient.request_map">request_map</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_transaction" href="#genshin.client.GenshinClient.request_transaction">request_transaction</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_webstatic" href="#genshin.client.GenshinClient.request_webstatic">request_webstatic</a></code></li>
<li><code><a title="genshin.client.GenshinClient.search_users" href="#genshin.client.GenshinClient.search_users">search_users</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_authkey" href="#genshin.client.GenshinClient.set_authkey">set_authkey</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_browser_cookies" href="#genshin.client.GenshinClient.set_browser_cookies">set_browser_cookies</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_cache" href="#genshin.client.GenshinClient.set_cache">set_cache</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_top_characters" href="#genshin.client.GenshinClient.set_top_characters">set_top_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_visibility" href="#genshin.client.GenshinClient.set_visibility">set_visibility</a></code></li>
<li><code><a title="genshin.client.GenshinClient.transaction_log" href="#genshin.client.GenshinClient.transaction_log">transaction_log</a></code></li>
<li><code><a title="genshin.client.GenshinClient.wish_history" href="#genshin.client.GenshinClient.wish_history">wish_history</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="genshin" href="index.html">genshin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="genshin.client.ChineseClient" href="#genshin.client.ChineseClient">ChineseClient</a></code></h4>
<ul class="two-column">
<li><code><a title="genshin.client.ChineseClient.ACT_ID" href="#genshin.client.ChineseClient.ACT_ID">ACT_ID</a></code></li>
<li><code><a title="genshin.client.ChineseClient.DETAIL_LEDGER_URL" href="#genshin.client.ChineseClient.DETAIL_LEDGER_URL">DETAIL_LEDGER_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.DS_SALT" href="#genshin.client.ChineseClient.DS_SALT">DS_SALT</a></code></li>
<li><code><a title="genshin.client.ChineseClient.GACHA_INFO_URL" href="#genshin.client.ChineseClient.GACHA_INFO_URL">GACHA_INFO_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.INFO_LEDGER_URL" href="#genshin.client.ChineseClient.INFO_LEDGER_URL">INFO_LEDGER_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.MAP_URL" href="#genshin.client.ChineseClient.MAP_URL">MAP_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.RECORD_URL" href="#genshin.client.ChineseClient.RECORD_URL">RECORD_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.REWARD_URL" href="#genshin.client.ChineseClient.REWARD_URL">REWARD_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.SIGNIN_SALT" href="#genshin.client.ChineseClient.SIGNIN_SALT">SIGNIN_SALT</a></code></li>
<li><code><a title="genshin.client.ChineseClient.STATIC_MAP_URL" href="#genshin.client.ChineseClient.STATIC_MAP_URL">STATIC_MAP_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.TAKUMI_URL" href="#genshin.client.ChineseClient.TAKUMI_URL">TAKUMI_URL</a></code></li>
<li><code><a title="genshin.client.ChineseClient.cache" href="#genshin.client.ChineseClient.cache">cache</a></code></li>
<li><code><a title="genshin.client.ChineseClient.claim_daily_reward" href="#genshin.client.ChineseClient.claim_daily_reward">claim_daily_reward</a></code></li>
<li><code><a title="genshin.client.ChineseClient.fetched_mi18n" href="#genshin.client.ChineseClient.fetched_mi18n">fetched_mi18n</a></code></li>
<li><code><a title="genshin.client.ChineseClient.get_monthly_rewards" href="#genshin.client.ChineseClient.get_monthly_rewards">get_monthly_rewards</a></code></li>
<li><code><a title="genshin.client.ChineseClient.get_reward_info" href="#genshin.client.ChineseClient.get_reward_info">get_reward_info</a></code></li>
<li><code><a title="genshin.client.ChineseClient.logger" href="#genshin.client.ChineseClient.logger">logger</a></code></li>
<li><code><a title="genshin.client.ChineseClient.paginator_cache" href="#genshin.client.ChineseClient.paginator_cache">paginator_cache</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genshin.client.ChineseMultiCookieClient" href="#genshin.client.ChineseMultiCookieClient">ChineseMultiCookieClient</a></code></h4>
<ul class="">
<li><code><a title="genshin.client.ChineseMultiCookieClient.sessions" href="#genshin.client.ChineseMultiCookieClient.sessions">sessions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genshin.client.GenshinClient" href="#genshin.client.GenshinClient">GenshinClient</a></code></h4>
<ul class="">
<li><code><a title="genshin.client.GenshinClient.ACT_ID" href="#genshin.client.GenshinClient.ACT_ID">ACT_ID</a></code></li>
<li><code><a title="genshin.client.GenshinClient.CALCULATOR_URL" href="#genshin.client.GenshinClient.CALCULATOR_URL">CALCULATOR_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.DETAIL_LEDGER_URL" href="#genshin.client.GenshinClient.DETAIL_LEDGER_URL">DETAIL_LEDGER_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.DS_SALT" href="#genshin.client.GenshinClient.DS_SALT">DS_SALT</a></code></li>
<li><code><a title="genshin.client.GenshinClient.GACHA_INFO_URL" href="#genshin.client.GenshinClient.GACHA_INFO_URL">GACHA_INFO_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.INFO_LEDGER_URL" href="#genshin.client.GenshinClient.INFO_LEDGER_URL">INFO_LEDGER_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.MAP_URL" href="#genshin.client.GenshinClient.MAP_URL">MAP_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.RECORD_URL" href="#genshin.client.GenshinClient.RECORD_URL">RECORD_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.REWARD_URL" href="#genshin.client.GenshinClient.REWARD_URL">REWARD_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.STATIC_MAP_URL" href="#genshin.client.GenshinClient.STATIC_MAP_URL">STATIC_MAP_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.TAKUMI_URL" href="#genshin.client.GenshinClient.TAKUMI_URL">TAKUMI_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.USER_AGENT" href="#genshin.client.GenshinClient.USER_AGENT">USER_AGENT</a></code></li>
<li><code><a title="genshin.client.GenshinClient.WEBSTATIC_URL" href="#genshin.client.GenshinClient.WEBSTATIC_URL">WEBSTATIC_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.YSULOG_URL" href="#genshin.client.GenshinClient.YSULOG_URL">YSULOG_URL</a></code></li>
<li><code><a title="genshin.client.GenshinClient.authkey" href="#genshin.client.GenshinClient.authkey">authkey</a></code></li>
<li><code><a title="genshin.client.GenshinClient.cache" href="#genshin.client.GenshinClient.cache">cache</a></code></li>
<li><code><a title="genshin.client.GenshinClient.calculator" href="#genshin.client.GenshinClient.calculator">calculator</a></code></li>
<li><code><a title="genshin.client.GenshinClient.claim_daily_reward" href="#genshin.client.GenshinClient.claim_daily_reward">claim_daily_reward</a></code></li>
<li><code><a title="genshin.client.GenshinClient.claimed_rewards" href="#genshin.client.GenshinClient.claimed_rewards">claimed_rewards</a></code></li>
<li><code><a title="genshin.client.GenshinClient.close" href="#genshin.client.GenshinClient.close">close</a></code></li>
<li><code><a title="genshin.client.GenshinClient.cookies" href="#genshin.client.GenshinClient.cookies">cookies</a></code></li>
<li><code><a title="genshin.client.GenshinClient.debug" href="#genshin.client.GenshinClient.debug">debug</a></code></li>
<li><code><a title="genshin.client.GenshinClient.diary_log" href="#genshin.client.GenshinClient.diary_log">diary_log</a></code></li>
<li><code><a title="genshin.client.GenshinClient.fetch_banner_ids" href="#genshin.client.GenshinClient.fetch_banner_ids">fetch_banner_ids</a></code></li>
<li><code><a title="genshin.client.GenshinClient.fetched_mi18n" href="#genshin.client.GenshinClient.fetched_mi18n">fetched_mi18n</a></code></li>
<li><code><a title="genshin.client.GenshinClient.genshin_accounts" href="#genshin.client.GenshinClient.genshin_accounts">genshin_accounts</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_activities" href="#genshin.client.GenshinClient.get_activities">get_activities</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_banner_details" href="#genshin.client.GenshinClient.get_banner_details">get_banner_details</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_banner_names" href="#genshin.client.GenshinClient.get_banner_names">get_banner_names</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_artifacts" href="#genshin.client.GenshinClient.get_calculator_artifacts">get_calculator_artifacts</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_characters" href="#genshin.client.GenshinClient.get_calculator_characters">get_calculator_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_calculator_weapons" href="#genshin.client.GenshinClient.get_calculator_weapons">get_calculator_weapons</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_character_details" href="#genshin.client.GenshinClient.get_character_details">get_character_details</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_character_talents" href="#genshin.client.GenshinClient.get_character_talents">get_character_talents</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_characters" href="#genshin.client.GenshinClient.get_characters">get_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_complete_artifact_set" href="#genshin.client.GenshinClient.get_complete_artifact_set">get_complete_artifact_set</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_diary" href="#genshin.client.GenshinClient.get_diary">get_diary</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_full_user" href="#genshin.client.GenshinClient.get_full_user">get_full_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_gacha_items" href="#genshin.client.GenshinClient.get_gacha_items">get_gacha_items</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_info" href="#genshin.client.GenshinClient.get_map_info">get_map_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_labels" href="#genshin.client.GenshinClient.get_map_labels">get_map_labels</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_locations" href="#genshin.client.GenshinClient.get_map_locations">get_map_locations</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_map_points" href="#genshin.client.GenshinClient.get_map_points">get_map_points</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_monthly_rewards" href="#genshin.client.GenshinClient.get_monthly_rewards">get_monthly_rewards</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_notes" href="#genshin.client.GenshinClient.get_notes">get_notes</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_partial_user" href="#genshin.client.GenshinClient.get_partial_user">get_partial_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_recommended_users" href="#genshin.client.GenshinClient.get_recommended_users">get_recommended_users</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_record_card" href="#genshin.client.GenshinClient.get_record_card">get_record_card</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_reward_info" href="#genshin.client.GenshinClient.get_reward_info">get_reward_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_spiral_abyss" href="#genshin.client.GenshinClient.get_spiral_abyss">get_spiral_abyss</a></code></li>
<li><code><a title="genshin.client.GenshinClient.get_user" href="#genshin.client.GenshinClient.get_user">get_user</a></code></li>
<li><code><a title="genshin.client.GenshinClient.hoyolab_uid" href="#genshin.client.GenshinClient.hoyolab_uid">hoyolab_uid</a></code></li>
<li><code><a title="genshin.client.GenshinClient.init" href="#genshin.client.GenshinClient.init">init</a></code></li>
<li><code><a title="genshin.client.GenshinClient.lang" href="#genshin.client.GenshinClient.lang">lang</a></code></li>
<li><code><a title="genshin.client.GenshinClient.logger" href="#genshin.client.GenshinClient.logger">logger</a></code></li>
<li><code><a title="genshin.client.GenshinClient.login_with_ticket" href="#genshin.client.GenshinClient.login_with_ticket">login_with_ticket</a></code></li>
<li><code><a title="genshin.client.GenshinClient.paginator_cache" href="#genshin.client.GenshinClient.paginator_cache">paginator_cache</a></code></li>
<li><code><a title="genshin.client.GenshinClient.redeem_code" href="#genshin.client.GenshinClient.redeem_code">redeem_code</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request" href="#genshin.client.GenshinClient.request">request</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_calculator" href="#genshin.client.GenshinClient.request_calculator">request_calculator</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_daily_reward" href="#genshin.client.GenshinClient.request_daily_reward">request_daily_reward</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_gacha_info" href="#genshin.client.GenshinClient.request_gacha_info">request_gacha_info</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_game_record" href="#genshin.client.GenshinClient.request_game_record">request_game_record</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_hoyolab" href="#genshin.client.GenshinClient.request_hoyolab">request_hoyolab</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_ledger" href="#genshin.client.GenshinClient.request_ledger">request_ledger</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_map" href="#genshin.client.GenshinClient.request_map">request_map</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_transaction" href="#genshin.client.GenshinClient.request_transaction">request_transaction</a></code></li>
<li><code><a title="genshin.client.GenshinClient.request_webstatic" href="#genshin.client.GenshinClient.request_webstatic">request_webstatic</a></code></li>
<li><code><a title="genshin.client.GenshinClient.search_users" href="#genshin.client.GenshinClient.search_users">search_users</a></code></li>
<li><code><a title="genshin.client.GenshinClient.session" href="#genshin.client.GenshinClient.session">session</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_authkey" href="#genshin.client.GenshinClient.set_authkey">set_authkey</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_browser_cookies" href="#genshin.client.GenshinClient.set_browser_cookies">set_browser_cookies</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_cache" href="#genshin.client.GenshinClient.set_cache">set_cache</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_cookies" href="#genshin.client.GenshinClient.set_cookies">set_cookies</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_top_characters" href="#genshin.client.GenshinClient.set_top_characters">set_top_characters</a></code></li>
<li><code><a title="genshin.client.GenshinClient.set_visibility" href="#genshin.client.GenshinClient.set_visibility">set_visibility</a></code></li>
<li><code><a title="genshin.client.GenshinClient.transaction_log" href="#genshin.client.GenshinClient.transaction_log">transaction_log</a></code></li>
<li><code><a title="genshin.client.GenshinClient.uid" href="#genshin.client.GenshinClient.uid">uid</a></code></li>
<li><code><a title="genshin.client.GenshinClient.wish_history" href="#genshin.client.GenshinClient.wish_history">wish_history</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genshin.client.MultiCookieClient" href="#genshin.client.MultiCookieClient">MultiCookieClient</a></code></h4>
<ul class="">
<li><code><a title="genshin.client.MultiCookieClient.close" href="#genshin.client.MultiCookieClient.close">close</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.cookies" href="#genshin.client.MultiCookieClient.cookies">cookies</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.request_daily_reward" href="#genshin.client.MultiCookieClient.request_daily_reward">request_daily_reward</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.session" href="#genshin.client.MultiCookieClient.session">session</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.sessions" href="#genshin.client.MultiCookieClient.sessions">sessions</a></code></li>
<li><code><a title="genshin.client.MultiCookieClient.set_cookies" href="#genshin.client.MultiCookieClient.set_cookies">set_cookies</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev21+g6d35cca</a>.</p>
</footer>
</body>
</html>